<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="javascript," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="Object类型到目前为止，我们看到的大多数引用类型值都是Object类型的实例；而且，Object也是ECMAScript中使用最多的一个类型。虽然Object的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。
创建Object实例的方式有两种。

第一种是使用new操作符后跟Object构造函数。

123var person = new Object();">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript引用类型">
<meta property="og:url" content="http://Lisiur.com/2016/08/10/JavaScript引用类型/index.html">
<meta property="og:site_name" content="Lisiur">
<meta property="og:description" content="Object类型到目前为止，我们看到的大多数引用类型值都是Object类型的实例；而且，Object也是ECMAScript中使用最多的一个类型。虽然Object的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。
创建Object实例的方式有两种。

第一种是使用new操作符后跟Object构造函数。

123var person = new Object();">
<meta property="og:updated_time" content="2017-03-06T03:01:23.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript引用类型">
<meta name="twitter:description" content="Object类型到目前为止，我们看到的大多数引用类型值都是Object类型的实例；而且，Object也是ECMAScript中使用最多的一个类型。虽然Object的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。
创建Object实例的方式有两种。

第一种是使用new操作符后跟Object构造函数。

123var person = new Object();">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> JavaScript引用类型 | Lisiur </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Lisiur</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                JavaScript引用类型
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-10T10:28:55+08:00" content="2016-08-10">
              2016-08-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/javascript笔记/" itemprop="url" rel="index">
                    <span itemprop="name">javascript笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/10/JavaScript引用类型/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/08/10/JavaScript引用类型/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><p>到目前为止，我们看到的大多数引用类型值都是Object类型的实例；而且，Object也是ECMAScript中使用最多的一个类型。虽然Object的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。</p>
<p>创建Object实例的方式有两种。</p>
<ol>
<li>第一种是使用new操作符后跟Object构造函数。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">person.name = <span class="string">"Nicholas"</span>;</div><div class="line">person.age = <span class="number">20</span>;</div></pre></td></tr></table></figure>
<ol>
<li>另一种方式是使用对象字面量表示法。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">	<span class="attr">name</span> : <span class="string">"Nicholas"</span>,</div><div class="line">	<span class="attr">age</span> : <span class="number">29</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h2><p>ECMAScript数组的每一项可以保存任何类型的数据。<br>创建数组的基本方式有两种。</p>
<ol>
<li>第一种是使用Array构造函数。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>()；</div><div class="line"></div><div class="line"><span class="comment">// 如果预先知道数组要保存的项目数量，也可以给构造函数传递该数量，而该数量会自动变成length属性的值。例如，下面的代码将创建length值为20的数组。</span></div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>（<span class="number">20</span>;</div><div class="line"></div><div class="line"><span class="comment">// 也可以向Array构造函数传递数组中应该包含的项。以下代码创建了一个包含3个字符串值的数组：</span></div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>（<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>）；</div><div class="line"></div><div class="line"><span class="comment">//当然，给构造函数传递一个值也可以创建数组。但这时候问题就复杂一点了，因为如果传递的是数值，则会按照该数值创建包含给定项数的数组；而如果传递的是其他类型的参数，则会创建包含那个值的只有一项的数组。</span></div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">// 创建一个包含三项的数组</span></div><div class="line"><span class="keyword">var</span> names = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"Greg"</span>); <span class="comment">// 创建一个包含1项， 即字符串“Greg”的数组</span></div></pre></td></tr></table></figure>
<ol>
<li>创建数组的第二种基本方式是使用数组字面量表示法。数组字面量由一对包含数组项的方括号表示，多个数组项之间以逗号隔开。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含三个字符串的数组</span></div><div class="line"><span class="keyword">var</span> names = []; <span class="comment">// 创建一个空数组</span></div><div class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,]; <span class="comment">// 不要这样！IE中为[1,2,undefined],其他为[1,2]</span></div><div class="line"><span class="keyword">var</span> options = [,,,,,]; <span class="comment">// 不要这样！</span></div></pre></td></tr></table></figure>
<p>在读取和设置数组的值时，要使用方括号并提供相应值的基于0的数字索引。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; </div><div class="line">alert(colors[<span class="number">0</span>]); <span class="comment">//显示第一项</span></div><div class="line">colors[<span class="number">2</span>] = <span class="string">"black"</span>; <span class="comment">// 修改第三项</span></div><div class="line">colors[<span class="number">3</span>] = <span class="string">"brown"</span>; <span class="comment">// 新增第四项</span></div></pre></td></tr></table></figure>
<p>数组的项数保存在其length属性中，这个属性始终会返回0或更大的值。</p>
<p>数组的length属性很有特点——它不是只读的。因此，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">colors.length = <span class="number">2</span>;</div><div class="line">alert([colors[<span class="number">2</span>]]); <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<blockquote>
<p>数组最多可以包含4 294 967 295个项，这几乎已经能够满足任何编程需求了。如果想添加的项数超过这个上限值，就会发生异常。而创建一个初始大小与这个上限值接近的数组，则可能会导致运行时间超长的脚本错误。</p>
</blockquote>
<h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><p>正常情况下<strong>instanceof</strong>就可以判断是否为数组。instanceof操作符的问题在于，它假定单一的全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。为了解决这个问题，ECMAScript 5新增了<strong>Array.isArray()</strong>方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。</p>
<blockquote>
<p>支持Array.isAr ray()方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 10.5+和Chrome。</p>
</blockquote>
<h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><p>所有对象都具有toLocaleString()、toString()和valueOf()方法。其中，调用数组的toString()和valueOf()方法会返回相同的值，即由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。实际上，为了创建这个字符串会调用数组每一项的toString()方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">alert(colors.toString()); <span class="comment">// red,blue,green</span></div><div class="line">alert(colors.valueOf()); <span class="comment">// red,blue,green</span></div><div class="line">alert(colors); <span class="comment">// red,blue,green</span></div></pre></td></tr></table></figure>
<p>使用join()方法，则可以使用不同的分隔符来构建这个字符串。join()方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">alert(colors.join(<span class="string">"|"</span>)); <span class="comment">// red|green|blue</span></div></pre></td></tr></table></figure>
<blockquote>
<p>如果不给join()方法传入任何值，或者给它传入undefined，则使用逗号作为分隔符。IE7及更早版本会错误的使用字符串”undefined”作为分隔符。<br>如果数组中的某一项的值是null或者undefined，那么该值在join()、toLocale-String()、toString()和valueOf()方法返回的结果中以空字符串表示。</p>
</blockquote>
<h3 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h3><p>ECMAScript为数组专门提供了<strong>push()</strong>和<strong>pop()</strong>方法，以便实现类似栈的行为。</p>
<p>push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。而pop()方法则从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。</p>
<h3 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h3><p>由于<strong>push()</strong>是向数组末端添加项的方法，因此要模拟队列只需一个从数组前端取得项的方法。实现这一操作的数组方法就是<strong>shift()</strong>，它能够移除数组中的第一个项并返回该项，同时将数组长度减1。结合使用shift()和push()方法，可以像使用队列一样使用数组。</p>
<p>ECMAScript还为数组提供了一个<strong>unshift()</strong>方法。顾名思义，unshift()与shift()的用途相反：它能在数组前端添加任意个项并返回新数组的长度。因此，同时使用unshift()和<strong>pop()</strong>方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项。</p>
<blockquote>
<p>IE7及更早版本对JavaScript的实现中存在一个偏差，其unshift()方法总是返回undefined而不是数组的新长度。IE8在非兼容模式下会返回正确的长度值。</p>
</blockquote>
<h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><ul>
<li><p>reverse()<br>reverse()方法会对反转数组项的顺序。</p>
</li>
<li><p>sort()<br>在默认情况下，sort()方法按升序排列数组项一一即最小的值位于最前面，最大的值排在最后面。为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</div><div class="line">values.sort();</div><div class="line">alert(values); <span class="comment">// 0,1,10,15,5</span></div></pre></td></tr></table></figure>
<p>可见，即使例子中值的顺序没有问题，但sort()方法也会根据测试字符串的结果改变原来的顺序。因为数值5虽然小于10，但在进行字符串比较时，”10”则位于”5”的前面，于是数组的顺序就被修改了。不用说，这种排序方式在很多情况下都不是最佳方案。因此sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。</p>
<p>比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">cmp</span>(<span class="params">value1, value2</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> value1 &lt; value2;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</div><div class="line">values.sort(cmp);</div><div class="line">alert(values); <span class="comment">// 0,1,5,10,15</span></div></pre></td></tr></table></figure>
<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><p>ECMAScript为操作已经包含在数组中的项提供了很多方法。</p>
<ul>
<li>concat()<br>concat()方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给concat()方法传递参数的情况下，它只是复制当前数组并返回副本。如果传递给concat()方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</div><div class="line"><span class="keyword">var</span> colors2 = colors.concat(<span class="string">"yellow"</span>, [<span class="string">"black"</span>, <span class="string">"brown"</span>]);</div><div class="line"></div><div class="line">alert(colors);  <span class="comment">// red,green,blue</span></div><div class="line">alert(colors2); <span class="comment">// red,green,blue,yellow,black,brown</span></div></pre></td></tr></table></figure>
<ul>
<li>slice()<br>能够基于当前数组中的一或多个项创建一个新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项一一但不包括结束位置的项。注意，slice()方法不会影响原始数组。</li>
</ul>
<blockquote>
<p>如果slice()方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。例如，在一个包含5项的数组上调用slice（-2，-1）与调用slice（3, 4）得到的结果相同。如果结束位置小于起始位置，则返回空数组。</p>
</blockquote>
<ul>
<li>splice()<br>splice()的主要用途是向数组的中部插入项，但使用这种方法的方式则有如下3种。<ul>
<li>删除：可以删除任意数量的项，只需指定2个参数：要删除的第一项的位置和要删除的项数。例如，<code>splice(0，2)</code>会删除数组中的前两项。</li>
<li>插入：可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，<code>splice(2,0, &quot;red&quot;, &quot;green&quot;)</code>会从当前数组的位置2开始插入字符串”red”和”green”。</li>
<li>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，<code>splice(2,1, &quot;red&quot;, &quot;green&quot;)</code>会删除当前数组位置2的项，然后再从位置2开始插入字符串”red”和”green”。</li>
</ul>
</li>
</ul>
<blockquote>
<p>splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。<br>splice在原数组上操作。</p>
</blockquote>
<h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><p>ECMAScript 5为数组实例添加了两个位置方法：<code>indexOf()</code>和<code>lastIndexOf()</code>。这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中，indexOf()方法从数组的开头（位置0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>];</div><div class="line">alert(numbers.indexOf(<span class="number">4</span>)); <span class="comment">// 3</span></div><div class="line">alert(numbers.lastIndexOf(<span class="number">4</span>)); <span class="comment">// 5</span></div><div class="line"></div><div class="line">alert(numbers.indexOf(<span class="number">4</span>,<span class="number">4</span>)); <span class="comment">// 5</span></div><div class="line">alert(numbers.lastIndexOf(<span class="number">4</span>,<span class="number">4</span>)); <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> person = &#123;<span class="attr">name</span>: <span class="string">"lisiur"</span>&#125;;</div><div class="line"><span class="keyword">var</span> people = [&#123;<span class="attr">name</span>: <span class="string">"lisiur"</span>&#125;];</div><div class="line"></div><div class="line"><span class="keyword">var</span> morePeople = [people];</div><div class="line"></div><div class="line">alert(people.indexOf(person)); <span class="comment">// -1</span></div><div class="line">alert(morePeople.indexOf(person)); <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<blockquote>
<p>使用indexOf()和lastIndexOf()方法查找特定项在数组中的位置非常简单，支持它们的浏览器包括IE9+、Firefox 2+、Safari 3+、Opera 9.5+和Chrome。</p>
</blockquote>
<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><p>ECMAScript 5为数组定义了5个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响this的值。传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响访问的返回值。以下是这5个迭代方法的作用。</p>
<ul>
<li><code>every()</code>：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。</li>
<li><code>filter()</code>:对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。</li>
<li><code>forEach()</code>：对数组中的每一项运行给定函数。这个方法没有返回值。</li>
<li><code>map()</code>：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>
<li><code>some()</code>：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。</li>
</ul>
<blockquote>
<p>以上方法都不会修改数组中的包含的值。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// every VS some</span></div><div class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> everyResult = numbers.every(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> (item&gt;<span class="number">2</span>);</div><div class="line">&#125;);</div><div class="line">alert(everyResult); <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> someResult = numbers.some(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> (item &gt; <span class="number">2</span>);</div><div class="line">&#125;);</div><div class="line">alert(someResult); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// filter</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> filterResult = numbersfilter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> (item &gt; <span class="number">2</span>);</div><div class="line">&#125;);</div><div class="line">alert(filterResult); <span class="comment">// [3,4,5,4,3]</span></div><div class="line"></div><div class="line"><span class="comment">// map</span></div><div class="line"><span class="keyword">var</span> mapResult = numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> item*<span class="number">2</span>;</div><div class="line">&#125;);</div><div class="line">alert(mapResult); <span class="comment">// [2,4,6,8,10,8,6,4,2]</span></div><div class="line"></div><div class="line"><span class="comment">// forEach</span></div><div class="line"></div><div class="line">numbers.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</div><div class="line">	<span class="comment">// do something</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>支持这些迭代方法的浏览器有IE9+、Firefox 2+、Safari 3+、Opera 9.5+和Chrome。</p>
</blockquote>
<h3 id="缩小方法"><a href="#缩小方法" class="headerlink" title="缩小方法"></a>缩小方法</h3><p>ECMAScript 5还新增了两个缩小数组的方法：reduce()和reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历到最后。而reduceRight()则从数组的最后一项开始，向前遍历到第一项。</p>
<p>这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为缩小基础的初始值。传给reduce()和reduceRight()的函数接收4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。</p>
<p>使用reduce()方法可以执行求数组中所有值之和的操作，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> sum = value.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> prev + cur;</div><div class="line">&#125;);</div><div class="line">alert(sum); <span class="comment">// 15</span></div></pre></td></tr></table></figure>
<p>reduceRight()的作用类似，只不过方向相反而已。</p>
<blockquote>
<p>持这两个缩小函数的浏览器有IE9+、Firefox 3+、Safari 4+、Opera 10.5和Chrome。</p>
</blockquote>
<h2 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h2><p>要创建一个日期对象，使用new操作符和Date构造函数即可</p>
<p><code>var now = new Date()</code></p>
<p>在调用Date构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数（即从UTC时间1970年1月1日午夜起至该日期止经过的毫秒数）。为了简化这一计算过程，ECMAScript提供了两个方法：Date.parse()和Date.UTC()。</p>
<p>其中，Date.parse()方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。ECMA-262没有定义Date.parse()应该支持哪种日期格式，因此这个方法的行为因实现而异，而且通常是因地区而异。将地区设置为美国的浏览器通常都接受下列日期格式：</p>
<ul>
<li>“月/日/年”，如6/13/2004;</li>
<li>“英文月名日，年”，如January12，2004;</li>
<li>“英文星期几英文月名日年时：分：秒时区”，如Tue May 25 2004 00:00:00 GMT-0700。</li>
<li>ISO 8601扩展格式YYYY-MM-DDTHH:mm:ss.sssZ（例如2004-05-25T00:00:00）。只有兼容ECMAScript 5的实现支持这种格式。</li>
</ul>
<p>例如，要为2004年5月25日创建一个日期对象，可以使用下面的代码:</p>
<p><code>var someDate = new Date(Date.parse(&quot;May 25, 2004&quot;));</code></p>
<p>如果传入Date.parse()方法的字符串不能表示日期，那么它会返回NaN。实际上，如果直接将表示日期的字符串传递给Date构造函数，也会在后台调用Date.parse()。换句话说，下面的代码与前面的例子是等价的：</p>
<p><code>var someDate = new Date(&quot;May 25, 2004&quot;);</code></p>
<p>这行代码将会得到与前面相同的日期对象。</p>
<blockquote>
<p>日期对象及其在不同浏览器中的实现有许多奇怪的行为。其中有一种倾向是将超出范围的值替换成当前的值，以便生成输出。例如，在解析”January 32, 2007”时，有的浏览器会将其解释为”February 1, 2007”。而Opera则倾向于插入当前月份的当前日期，返回”January当前日期，2007”。也就是说，如果在2007年9月21日运行前面的代码，将会得到”January 21, 2007”（都是21日）。</p>
</blockquote>
<p>Date.UTC()方法同样也返回表示日期的毫秒数，但它与Date.parse()在构建值时使用不同的信息。Date.UTC()的参数分别是年份、基于0的月份（一月是0，二月是1，以此类推）、月中的哪一天（1到31）、小时数（0到23）、分钟、秒以及毫秒数。在这些参数中，只有前两个参数（年和月）是必需的。如果没有提供月中的天数，则假设天数为1；如果省略其他参数，则统统假设为0。以下是两个使用Date.UTC()方法的例子：</p>
<p>GMT时间2000年1月1日午夜零时：<br><code>var y2k = new Date(Date.UTC(2000, 0));</code><br>GMT时间2005年5月5日下午5:55:55：<br><code>var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));</code></p>
<p>如同模仿Date.parse()一样，Date构造函数也会模仿Date.UTC()，但有一点明显不同：日期和时间都基于本地时区而非GMT来创建。不过，Date构造函数接收的参数仍然与Date.UTC()相同。因此，如果第一个参数是数值，Date构造函数就会假设该值是日期中的年份，而第二个参数是月份，以此类推。</p>
<p>本地时间2000年1月1日午夜零时：<br><code>var y2k = new Date(2000, 0);</code><br>本地时间2005年5月5日下午5:55:55：<br><code>var allFives = new Date(2005, 4, 5, 17, 55, 55);</code></p>
<p>ECMAScript 5添加了Data.now()方法，返回表示调用这个方法时的日期和时间的毫秒数。这个方法简化了使用Data对象分析代码的工作。</p>
<p><code>var start = Date.now()</code></p>
<blockquote>
<p>支持Data.now()方法的浏览器包括IE9+、Firefox 3+、Safari 3+、Opera 10.5和Chrome。在不支持它的浏览器中，使用+操作符把Data对象转换成字符串，也可以达到同样的目的。</p>
</blockquote>
<h3 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h3><p>与其他引用类型一样，Date类型也重写了toLocaleString()、toString()和valueOf()方法；但这些方法(toLocaleString()、toString())回的值与其他类型中的方法不同。<br>Date类型的toLocaleString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间。这大致意味着时间格式中会包含AM或PM，但不会包含时区信息（当然，具体的格式会因浏览器而异）。而toString()方法则通常返回带有时区信息的日期和时间，其中时间一般以军用时间（即小时的范围是0到23）表示。</p>
<blockquote>
<p>这两个方法在不同的浏览器中返回的日期和时间格式可谓大相径庭。事实上，toLocaleString()和toString()的这一差别仅在调试代码时比较有用，而在显示日期和时间时没有什么价值。</p>
<p>至于Date类型的valueOf()方法，则根本不返回字符串，而是返回日期的毫秒表示。因此，可以方便使用比较操作符（小于或大于）来比较日期值。</p>
</blockquote>
<h3 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h3><p>Date类型还有一些专门用于将日期格式化为字符串的方法，这些方法如下。</p>
<ul>
<li>toDateString()——以特定于实现的格式显示星期几、月、日和年；</li>
<li>toTimeString()——以特定于实现的格式显示时、分、秒和时区；</li>
<li>toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年；</li>
<li>toLocaleTimeString()——以特定于实现的格式显示时、分、秒；</li>
<li>toUTCString()——以特定于实现的格式完整的UTC日期。</li>
</ul>
<blockquote>
<p>与toLocaleString()和toString()方法一样，以上这些字符串格式方法的输出也是因浏览器而异的，因此没有哪一个方法能够用来在用户界面中显示一致的日期信息。</p>
</blockquote>
<h3 id="日期-时间组件方法"><a href="#日期-时间组件方法" class="headerlink" title="日期/时间组件方法"></a>日期/时间组件方法</h3><ul>
<li><code>getTime()</code><br>返回表示日期的毫秒数；与valueOf()方法返回的值相同 </li>
<li><code>setTime(毫秒)</code><br>以毫秒数设置日期，会改变整个日期 </li>
<li><code>getFullYear()</code><br>取得4位数的年份（如2007而非仅07） </li>
<li><code>getUTCFullYear()</code><br>返回UTC日期的4位数年份 </li>
<li><code>setFullYear(年)</code><br>设置日期的年份。传入的年份值必须是4位数字（如2007而非仅07） </li>
<li><code>setUTCFullYear(年)</code><br>设置UTC日期的年份。传入的年份值必须是4位数字（如2007而非仅07） </li>
<li><code>getMonth()</code><br>返回日期中的月份，其中0表示一月，11表示十二月 </li>
<li><code>getUTCMonth()</code><br>返回UTC日期中的月份，其中0表示一月，11表示十二月 </li>
<li><code>setMonth(月)</code><br>设置日期的月份。传入的月份值必须大于0，超过11则增加年份 </li>
<li><code>setUTCMonth(月)</code><br>设置UTC日期的月份。传入的月份值必须大于0，超过11则增加年份 </li>
<li><code>getDate()</code><br>返回日期月份中的天数（1到31） </li>
<li><code>getUTCDate()</code><br>返回UTC日期月份中的天数（1到31） </li>
<li><code>setDate(日)</code><br>设置日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份 </li>
<li><code>setUTCDate(日)</code><br>设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份 </li>
<li><code>getDay()</code><br>返回日期中星期的星期几（其中0表示星期日，6表示星期六） </li>
<li><code>getUTCDay()</code><br>返回UTC日期中星期的星期几（其中0表示星期日，6表示星期六） </li>
<li><code>getHours()</code><br>返回日期中的小时数（0到23） </li>
<li><code>getUTCHours()</code><br>返回UTC日期中的小时数（0到23） </li>
<li><code>setHours(时)</code><br>设置日期中的小时数。传入的值超过了23则增加月份中的天数 </li>
<li><code>setUTCHours(时)</code><br>设置UTC日期中的小时数。传入的值超过了23则增加月份中的天数 </li>
<li><code>getMinutes()</code><br>返回日期中的分钟数（0到59） </li>
<li><code>getUTCMinutes()</code><br>返回UTC日期中的分钟数（0到59） </li>
<li><code>setMinutes(分)</code><br>设置日期中的分钟数。传入的值超过59则增加小时数 </li>
<li><code>setUTCMinutes(分)</code><br>设置UTC日期中的分钟数。传入的值超过59则增加小时数 </li>
<li><code>getSeconds()</code><br>返回日期中的秒数（0到59） </li>
<li><code>getUTCSeconds()</code><br>返回UTC日期中的秒数（0到59） </li>
<li><code>setSeconds(秒)</code><br>设置日期中的秒数。传入的值超过了59会增加分钟数 </li>
<li><code>setUTCSeconds(秒)</code><br>设置UTC日期中的秒数。传入的值超过了59会增加分钟数 </li>
<li><code>getMilliseconds()</code><br>返回日期中的毫秒数 </li>
<li><code>getUTCMilliseconds()</code><br>返回UTC日期中的毫秒数 </li>
<li><code>setMilliseconds(毫秒)</code><br>设置日期中的毫秒数 </li>
<li><code>setUTCMilliseconds(毫秒)</code><br>设置UTC日期中的毫秒数 </li>
<li><code>getTimezoneOffset()</code><br>返回本地时间与UTC时间相差的分钟数。例如，美国东部标准时间返回300。在某地进入夏令时的情况下，这个值会有所变化</li>
</ul>
<h2 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h2><p>ECMAScript通过RegExp类型来支持正则表达式。</p>
<p><code>var expression = /pattern/falgs</code></p>
<p>其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。正则表达式的匹配模式支持下列3个标志。</p>
<ul>
<li>g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；</li>
<li>i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；</li>
<li>m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。</li>
</ul>
<p>因此，一个正则表达式就是一个模式与上述3个标志的组合体。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 匹配字符串中所有"at"的实例</div><div class="line"> * /</div><div class="line">var pattern1 = /at/g;</div><div class="line"></div><div class="line">/*</div><div class="line"> * 匹配第一个"bat"或"cat",不区分大小写</div><div class="line"> * /</div><div class="line">var pattern2 = /[bc]at/i;</div><div class="line"></div><div class="line">/*</div><div class="line"> * 匹配所有以"at"结尾的3个字符的组合，不区分大小写</div><div class="line"> * /</div><div class="line">var pattern3 = /.at/gi;</div></pre></td></tr></table></figure>
<p>与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：<br><code>( ) [ ] { } \ | ^ $ ? * + .</code></p>
<p>另一种创建正则表达式的方式是使用RegExp构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。可以使用字面量定义的任何表达式，都可以使用构造函数来定义:</p>
<p><code>var pattern = new RegExp(&quot;[bc]at&quot;, &quot;i&quot;);</code></p>
<blockquote>
<p>要注意的是，传递给RegExp构造函数的两个参数都是字符串（不能把正则表达式字面量传递给RegExp构造函数）。</p>
</blockquote>
<p>由于RegExp构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此，例如\n（字符\在字符串中通常被转义为\，而在正则表达式字符串中就会变成\\）。下表给出了一些模式，左边是这些模式的字面量形式，右边是使用RegExp构造函数定义相同模式时使用的字符串。</p>
<table>
<thead>
<tr>
<th>字面量模式</th>
<th>等价的字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>/[bc]at/</td>
<td>“\[bc\]at”</td>
</tr>
<tr>
<td>/.at/</td>
<td>“\.at”</td>
</tr>
<tr>
<td>/name\/age/</td>
<td>“name\/age”</td>
</tr>
<tr>
<td>/\d.\d{l,2}/</td>
<td>“\d.\d[l,2}”</td>
</tr>
<tr>
<td>/\w\hello\123/</td>
<td>“\w\\hello\\123”</td>
</tr>
</tbody>
</table>
<p>使用正则表达式字面量和使用RegExp构造函数创建的正则表达式不一样。在ECMAScript 3中，正则表达式字面量始终会共享同一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例。</p>
<h3 id="RegExp实例属性"><a href="#RegExp实例属性" class="headerlink" title="RegExp实例属性"></a>RegExp实例属性</h3><p>RegExp的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。</p>
<ul>
<li>global:布尔值，表示是否设置了g标志。</li>
<li>ignoreCase:布尔值，表示是否设置了i标志。</li>
<li>lastIndex:整数，表示开始搜索下一个匹配项的字符位置，从0算起。</li>
<li>multiline:布尔值，表示是否设置了m标志。</li>
<li>source:正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。</li>
</ul>
<h3 id="RegExp实例方法"><a href="#RegExp实例方法" class="headerlink" title="RegExp实例方法"></a>RegExp实例方法</h3><ul>
<li>exec()<br>RegExp对象的主要方法是exec()，该方法是专门为捕获组而设计的。exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null。返回的数组虽然是Array的实例，但包含两个额外的属性：index和input。其中，index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"mom and dad and baby"</span>;</div><div class="line"><span class="keyword">var</span> pattern = <span class="regexp">/mom( and dad( and baby)?)?/gi</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> matches = pattern.exec(text);</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * [ 'mom and dad and baby',</div><div class="line"> *   ' and dad and baby',</div><div class="line"> *   ' and baby',</div><div class="line"> *   index: 0,</div><div class="line"> *   input: 'mom and dad and baby' ]</div><div class="line"> */</div></pre></td></tr></table></figure>
<p>对于exec()方法而言，即使在模式中设置了全局标志（g），它每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项</p>
<ul>
<li>test()<br>正则表达式的第二个方法是test()，它接受一个字符串参数。在模式与该参数匹配的情况下返回true；否则，返回false。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便。因此，test()方法经常被用在if语句中。</li>
</ul>
<blockquote>
<p>RegExp实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量，与创建正则表达式的方式无关。</p>
<p>正则表达式的valueOf()方法返回正则表达式本身。</p>
</blockquote>
<h3 id="RegExp构造函数属性"><a href="#RegExp构造函数属性" class="headerlink" title="RegExp构造函数属性"></a>RegExp构造函数属性</h3><p>RegExp构造函数包含一些属性（这些属性在其他语言中被看成是静态属性）。这些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。关于这些属性的另一个独特之处，就是可以通过两种方式访问它们。换句话说，这些属性分别有一个长属性名和一个短属性名（Opera是例外，它不支持短属性名）。下表列出了RegExp构造函数的属性。</p>
<table>
<thead>
<tr>
<th>长属性名</th>
<th>短属性名</th>
<th>说明               </th>
</tr>
</thead>
<tbody>
<tr>
<td>input</td>
<td>$_</td>
<td>最近一次要匹配的字符串。Opera未实现此属性。</td>
</tr>
<tr>
<td>lastMatch</td>
<td>$&amp;</td>
<td>最近一次的匹配项。Opera未实现此属性。</td>
</tr>
<tr>
<td>lastParen</td>
<td>$+</td>
<td>最近一次匹配的捕获组。Opera未实现此属性</td>
</tr>
<tr>
<td>leftContext</td>
<td>$`</td>
<td>input字符串中lastMatch之前的文本。</td>
</tr>
<tr>
<td>multiline</td>
<td>$*</td>
<td>布尔值，表示是否所有表达式都使用多行模式。IE和Opera未实现此属性</td>
</tr>
<tr>
<td>rightContext</td>
<td>$’</td>
<td>Input字符串中lastMatch之后的文本。</td>
</tr>
</tbody>
</table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"this has been a short summer"</span>;</div><div class="line"><span class="keyword">var</span> pattern = <span class="regexp">/(.)hort/g</span>;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Opera 不支持 input, lastMatch, lastParen, multiline</div><div class="line"> * IE    不支持 multiline</div><div class="line"> * /</div><div class="line"></div><div class="line">if (pattern.test(text)) &#123;</div><div class="line">	alert(RegExp.input);  // this has been a short summer</div><div class="line">	alert(RegExp.leftContext);  // this has been a</div><div class="line">	alert(RegExp.rightContext); // summer</div><div class="line">	alert(RegExp.lastMatch); // short</div><div class="line">	alert(RegExp.lastParen); // s</div><div class="line">	alert(RegExp.multiline); // false</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了上面介绍的几个属性之外，还有多达9个用于存储捕获组的构造函数属性。访问这些属性的语法是<code>RegExp.$1</code>、<code>RegExp.$2</code>…<code>RegExp.$9</code>，分别用于存储第一、第二……第九个匹配的捕获组。在调用exec()或test()方法时，这些属性会被自动填充。</p>
<h3 id="模式的局限性"><a href="#模式的局限性" class="headerlink" title="模式的局限性"></a>模式的局限性</h3><p>尽管ECMAScript中的正则表达式功能还是比较完备的，但仍然缺少某些语言（特别是Perl）所支持的高级正则表达式特性。下面列出了ECMAScript正则表达式不支持的特性。</p>
<ul>
<li>匹配字符串开始和结尾的\A和\Z锚</li>
<li>向后查找（lookbehind）</li>
<li>并集和交集类□ 原子组（atomic grouping）</li>
<li>Unicode支持（单个字符除外，如\uFFFF）</li>
<li>命名的捕获组</li>
<li>s（single，单行）和*（free-spacing，无间隔）匹配模式</li>
<li>条件匹配</li>
<li>正则表达式注释</li>
</ul>
<h2 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h2><h3 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h3><p>javascript中的函数没有重载，后定义的同名函数会替代之前定义的函数。因为函数名知识一个指向函数的指针而已。后定义的同名函数，只是重新创建一个函数对象，并修改函数名的指向。</p>
<h3 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h3><p>解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(sum(<span class="number">10</span>, <span class="number">10</span>));</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码完全可以正常运行。因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，JavaScript引擎也能把函数声明提升到顶部。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(sum(<span class="number">10</span>, <span class="number">10</span>));</div><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>以上代码之所以会在运行期间产生错误，原因在于函数位于一个初始化语句中，而不是一个函数声明。换句话说，在执行到函数所在的语句之前，变量sum中不会保存有对函数的引用；而且，由于第一行代码就会导致”unexpected identifier”（意外标识符）错误，实际上也不会执行到下一行。</p>
<blockquote>
<p>除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。</p>
<p>也可以同时使用函数声明和函数表达式，例如var sum = function sum(){}。不过，这种语法在Safari中会导致错误。</p>
</blockquote>
<h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3><p>因为ECMAScript中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeFunction</span>(<span class="params">someFunction, someArgument</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> someFunction(someArgument);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 这个函数接受两个参数。第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。然后，就可以像下面的例子一样传递函数了。</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add10</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> num + <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = callSomeFunction(add10, <span class="number">10</span>);</div><div class="line">alert(result); <span class="comment">// 20</span></div></pre></td></tr></table></figure>
<p>当然，可以从一个函数中返回另一个函数，而且这也是极为有用的一种技术。例如，假设有一个对象数组，我们想要根据某个对象属性对数组进行排序。而传递给数组sort()方法的比较函数要接收两个参数，即要比较的值。可是，我们需要一种方式来指明按照哪个属性来排序。要解决这个问题，可以定义一个函数，它接收一个属性名，然后根据这个属性名来创建一个比较函数，下面就是这个函数的定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFuntion</span>(<span class="params">propertyName</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> value1 = object1[propertyName];</div><div class="line">		<span class="keyword">var</span> value2 = object2[propertyName];</div><div class="line">		<span class="keyword">return</span> value1 &gt; value2;</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 这个函数定义看起来有点复杂，但实际上无非就是在一个函数中嵌套了另一个函数，而且内部函数前面加了一个return操作符。在内部函数接收到propertyName参数后，它会使用方括号表示法来取得给定属性的值。取得了想要的属性值之后，定义比较函数就非常简单了。上面这个函数可以像在下面例子中这样使用。 */</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> data = [&#123;<span class="attr">name</span>: <span class="string">"A"</span>, <span class="attr">age</span>: <span class="number">28</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">"B"</span>, <span class="attr">age</span>: <span class="number">26</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">"C"</span>, <span class="attr">age</span>: <span class="number">29</span>&#125;];</div><div class="line"></div><div class="line">data.sort(createComparisonFunction(<span class="string">"age"</span>));</div><div class="line">alert(data[<span class="number">0</span>].name); <span class="comment">// "C"</span></div></pre></td></tr></table></figure>
<h3 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h3><p>在函数内部，有两个特殊的对象：arguments和this。</p>
<ul>
<li>arguments是一个类数组对象，包含着传入函数中的所有参数。虽然arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。请看下面这个非常经典的阶乘函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span>(num &lt;=<span class="number">1</span> ) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">return</span> fatorial(num<span class="number">-1</span>) * num;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义阶乘函数一般都要用到递归算法；如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名factorial紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用arguments.callee。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span>(num &lt;=<span class="number">1</span> ) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>) * num;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个重写后的factorial()函数的函数体内，没有再引用函数名factorial。这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> trueFactorial = factorial;</div><div class="line"></div><div class="line">factorial = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">alert(trueFactorial(<span class="number">5</span>)); <span class="comment">// 120</span></div><div class="line">alert(factorial(<span class="number">5</span>));  <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<ul>
<li><p>this，其行为与Java和C#中的this大致类似。换句话说，this引用的是函数据以执行的环境对象一一或者也可以说是this值（当在网页的全局作用域中调用函数时，this对象引用的就是window）。</p>
</li>
<li><p>caller, 这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null。</p>
</li>
</ul>
<blockquote>
<p>当函数在严格模式下运行时，访问arguments.callee会导致错误。ECMAScript 5还定义了arguments.caller属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是undefined。定义这个属性是为了分清arguments.caller和函数的caller属性。以上变化都是为了加强这门语言的安全性，这样第三方代码就不能在相同的环境里窥视其他代码了。</p>
<p>严格模式还有一个限制：不能为函数的caller属性赋值，否则会导致错误。</p>
</blockquote>
<h3 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li><p>length<br>length属性表示函数希望接收的命名参数的个数(即定义函数时，显式设置的参数的个数)</p>
</li>
<li><p>prototype<br>对于ECMAScript中的引用类型而言，prototype是保存它们所有实例方法的真正所在。换句话说，诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问罢了。</p>
<blockquote>
<p>在ECMAScript 5中，prototype属性是不可枚举的，因此使用for-in无法发现。</p>
</blockquote>
</li>
</ul>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。</p>
<ul>
<li>apply()<br>apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例，也可以是arguments对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, [num1, num2]);</div><div class="line">	<span class="comment">// return sum.apply(this, arguments);</span></div><div class="line">&#125;</div><div class="line">alert(callSum(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20</span></div></pre></td></tr></table></figure>
<ul>
<li>call()<br>对于call()方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> sum.call(<span class="keyword">this</span>, num1, num2);</div><div class="line">&#125;</div><div class="line">alert(callSum(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20</span></div></pre></td></tr></table></figure>
<p>事实上，传递参数并非apply()和call()真正的用武之地；它们真正强大的地方是能够扩充函数赖以运行的作用域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</div><div class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.color);</div><div class="line">&#125;</div><div class="line"></div><div class="line">sayColor(); <span class="comment">// red</span></div><div class="line"></div><div class="line">sayColor.call(<span class="keyword">this</span>); <span class="comment">// red</span></div><div class="line">sayColor.call(<span class="built_in">window</span>); <span class="comment">// red</span></div><div class="line">sayColor.call(o); <span class="comment">// blue</span></div></pre></td></tr></table></figure>
<ul>
<li>bind()<br>这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</div><div class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.color);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> objectSayColor = sayColor.bind(o);</div><div class="line">objectSayColor(); <span class="comment">// "blue"</span></div></pre></td></tr></table></figure>
<blockquote>
<p>支持bind()方法的浏览器有IE9+、Firefox 4+、Safari 5.1+、Opera 12+和Chrome。</p>
</blockquote>
<ul>
<li>toLocaleString() &amp;&amp; toString() &amp;&amp; valueOf()<br>每个函数继承的toLocaleString()和toString()方法始终都返回函数的代码。返回代码的格式则因浏览器而异一一有的返回的代码与源代码中的函数代码一样，而有的则返回函数代码的内部表示，即由解析器删除了注释并对某些代码作了改动后的代码。由于存在这些差异，我们无法根据这两个方法返回的结果来实现任何重要功能；不过，这些信息在调试代码时倒是很有用。另外一个继承的valueOf()方法同样也只返回函数代码。</li>
</ul>
<h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><p>为了便于操作基本类型值，ECMAScript还提供了3个特殊的引用类型：Boolean、Number和String。这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。</p>
<h3 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h3><p>Boolean类型是与布尔值对应的引用类型。要创建Boolean对象，可以像下面这样调用Boolean构造函数并传入true或false值。</p>
<p><code>var booleanObject = new Boolean(true);</code></p>
<p>Boolean类型的实例重写了valueOf()方法，返回基本类型值重写了toString()方法，返回字符串”true”和”false”。可是，Boolean对象在ECMAScript中的用处不大，因为它经常会造成人们的误解。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> falseObj = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</div><div class="line">falseObj &amp;&amp; <span class="literal">true</span>; <span class="comment">// true</span></div></pre></td></tr></table></figure>
<blockquote>
<p>建议永远不要使用Boolean对象。</p>
</blockquote>
<h3 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h3><p>Number是与数字值对应的引用类型。要创建Number对象，可以在调用Number构造函数时向其中传递相应的数值。下面是一个例子。</p>
<p><code>var numberObj = new Number(10);</code></p>
<p>与Boolean类型一样，Number类型也重写了valueOf()、toLocaleString()和toString()方法。重写后的valueOf()方法返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的数值。可以为toString()方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</div><div class="line">alert(num.toString(<span class="number">2</span>)); <span class="comment">// "1010"</span></div></pre></td></tr></table></figure>
<p>除了继承的方法之外，Number类型还提供了一些用于将数值格式化为字符串的方法。</p>
<ul>
<li>toFixed()<br>按照指定的小数位返回数值的字符串表示</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">10.005</span>;</div><div class="line">alert(num.toFixed(<span class="number">2</span>)); <span class="comment">//"10.01"</span></div></pre></td></tr></table></figure>
<blockquote>
<p>在给toFixed()传入0的情况下，IE8及之前版本不能正确舍入范围在{（-0.94，-0.5]，[0.5，0.94）}之间的值。对于这个范围内的值，IE会返回0，而不是-1或1；其他浏览器都能返回正确的值。IE9修复了这个问题。</p>
</blockquote>
<ul>
<li>toExponential()<br>接收一个参数，而且该参数同样也是指定输出结果中的小数位数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</div><div class="line">alert(num.toExponential(<span class="number">1</span>)); <span class="comment">//"1.0e+1"</span></div></pre></td></tr></table></figure>
<ul>
<li>toPrecision()<br>对于一个数值来说，toPrecision()方法可能会返回固定大小（fixed）格式，也可能返回指数（exponential）格式；具体规则是看哪种格式最合适。</li>
</ul>
<h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>String类型是字符串的对象包装类型，可以像下面这样使用String构造函数来创建。</p>
<p><code>var stringObj = new String(&quot;Hello World&quot;);</code></p>
<p>String对象的方法也可以在所有基本的字符串值中访问到。其中，继承的valueOf()、toLocale-String()和toString()方法，都返回对象所表示的基本字符串值。</p>
<p>String类型的每个实例都有一个length属性，表示字符串中包含多个字符。</p>
<h4 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h4><ul>
<li>charAt()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"Hello World"</span>;</div><div class="line">alert(stringValue.charAt(<span class="number">1</span>)); <span class="comment">// "e"</span></div></pre></td></tr></table></figure>
<ul>
<li>charCodeAt()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"Hello World"</span>;</div><div class="line">alert(stringValue.charCodeAt(<span class="number">1</span>)); <span class="comment">// 101</span></div></pre></td></tr></table></figure>
<blockquote>
<p>ECMAScript5还定义了另一个访问个别字符的方法。在支持浏览器中，可以使用方括号加数字索引来访问字符串中的特定字符<br>使用方括号表示法访问个别字符的语法得到了IE8及Firefox、Safari、Chrome和Opera所有版本的支持。如果是在IE7及更早版本中使用这种语法，会返回undefined值（尽管根本不是特殊的undefined值）。</p>
</blockquote>
<h4 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h4><ul>
<li>concat()<br>用于将一或多个字符串拼接起来，返回拼接得到的新字符串。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello "</span>;</div><div class="line"><span class="keyword">var</span> result = stringValue.concat(<span class="string">"world"</span>);</div><div class="line">alert(result); <span class="comment">// "hello world"</span></div><div class="line">alert(stringValue); <span class="comment">//"hello "</span></div><div class="line"></div><div class="line">result = stringValue.concat(<span class="string">"world"</span>, <span class="string">"!"</span>); <span class="comment">// "hello world!"</span></div></pre></td></tr></table></figure>
<ul>
<li>slice()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello"</span>;</div><div class="line"><span class="keyword">var</span> result = stringValue.slice(<span class="number">3</span>); <span class="comment">// "lo"</span></div><div class="line"><span class="keyword">var</span> result = stringValue.slice(<span class="number">3</span>,<span class="number">4</span>); <span class="comment">// "l"</span></div></pre></td></tr></table></figure>
<ul>
<li>substring()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello "</span>;</div><div class="line"><span class="keyword">var</span> result = stringValue.substring(<span class="number">3</span>,<span class="number">4</span>); <span class="comment">// "l"</span></div></pre></td></tr></table></figure>
<ul>
<li>substr()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello"</span>;</div><div class="line"><span class="keyword">var</span> result = stringValue.substr(<span class="number">3</span>); <span class="comment">// "lo"</span></div><div class="line"><span class="keyword">var</span> result = stringValue.substr(<span class="number">3</span>,<span class="number">1</span>); <span class="comment">// "l"</span></div></pre></td></tr></table></figure>
<p>在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。其中，slice()方法会将传入的负值与字符串的长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0。最后，substring()方法会把所有负值参数都转换为0。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</div><div class="line">stringValue.slice(<span class="number">-3</span>); <span class="comment">// "rld"</span></div><div class="line">stringValue.substring(<span class="number">-3</span>); <span class="comment">// "hello world"</span></div><div class="line">stringValue.substr(<span class="number">-3</span>); <span class="comment">// "rld"</span></div><div class="line">stringValue.slice(<span class="number">3</span>,<span class="number">-4</span>); <span class="comment">// "lo w"</span></div><div class="line">stringValue.substring(<span class="number">3</span>,<span class="number">-4</span>); <span class="comment">// "hel"</span></div><div class="line">stringValue.substr(<span class="number">3</span>,<span class="number">-4</span>); <span class="comment">// ""</span></div></pre></td></tr></table></figure>
<blockquote>
<p>IE的JavaScript实现在处理向substr()方法传递负值的情况时存在问题，它会返回原始的字符串。IE9修复了这个问题。</p>
</blockquote>
<h4 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h4><ul>
<li>indexOf()</li>
<li>lastIndexOf()</li>
</ul>
<p>这两个方法都是从一个字符串中搜索给定的子字符串，然后返子字符串的位置（如果没有找到该子字符串，则返回-1）。这两个方法的区别在于：indexOf()方法从字符串的开头向后搜索子字符串，而lastIndexOf()方法是从字符串的末尾向前搜索子字符串。</p>
<h4 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim()方法"></a>trim()方法</h4><p>ECMAScript 5为所有字符串定义了trim()方法。这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。</p>
<blockquote>
<p>支持这个方法的浏览器有IE9+、Firefox 3.5+、Safari 5+、Opera 10.5+和Chrome。此外，Firefox 3.5+、Safari 5+和Chrome8+还支持非标准的trimLeft()和trimRight()方法，分别用于删除字符串开头和末尾的空格。</p>
</blockquote>
<h4 id="字符串大小转换方法"><a href="#字符串大小转换方法" class="headerlink" title="字符串大小转换方法"></a>字符串大小转换方法</h4><ul>
<li>toLowerCase()</li>
<li>toLocaleLowerCase()</li>
<li>toUpperCase()</li>
<li>toLocaleUpperCase()</li>
</ul>
<p>toLowerCase()和toUpperCase()是两个经典的方法，借鉴自java.lang.String中的同名方法。而toLocaleLowerCase()和toLocaleUpperCase()方法则是针对特定地区的实现。对有些地区来说，针对地区的方法与其通用方法得到的结果相同，但少数语言（如土耳其语）会为Unicode大小写转换应用特殊的规则，这时候就必须使用针对地区的方法来保证实现正确的转换。</p>
<blockquote>
<p>一般来说，在不知道自己的代码将在哪种语言环境中运行的情况下，还是使用针对地区的方法更稳妥一些。</p>
</blockquote>
<h4 id="字符串的模式匹配方法"><a href="#字符串的模式匹配方法" class="headerlink" title="字符串的模式匹配方法"></a>字符串的模式匹配方法</h4><ul>
<li>match()<br>在字符串上调用这个方法，本质上与调用RegExp的exec()方法相同。match()方法只接受一个参数，要么是一个正则表达式，要么是一个RegExp对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"cat bat sat fat"</span></div><div class="line"><span class="keyword">var</span> pattern = <span class="regexp">/.at/</span></div><div class="line"><span class="keyword">var</span> matches = text.match(pattern) <span class="comment">// [ 'cat', index: 0, input: 'cat bat sat fat' ]</span></div></pre></td></tr></table></figure>
<ul>
<li>search()<br>这个方法的唯一参数与match()方法的参数相同：由字符串或RegExp对象指定的一个正则表达式。search()方法返回字符串中第一个匹配项的索引；如果没有找到匹配项，则返回-1。而且，search()方法始终是从字符串开头向后查找模式。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"cat bat sat fat"</span></div><div class="line"><span class="keyword">var</span> pos = text.search(<span class="regexp">/at/</span>) <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<ul>
<li>replace()<br>这个方法接受两个参数：第一个参数可以是一个RegExp对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局（g）标志。</li>
</ul>
<p>如果第二个参数是字符串，那么还可以使用一些特殊的字符序列，将正则表达式操作得到的值插入到结果字符串中。下表列出了ECMAScript提供的这些特殊的字符序列。</p>
<table>
<thead>
<tr>
<th>字符序列</th>
<th>替换文本</th>
</tr>
</thead>
<tbody>
<tr>
<td>$$</td>
<td>$</td>
</tr>
<tr>
<td>$&amp;</td>
<td>匹配整个模式的子字符串。与RegExp.lastMatch的值相同</td>
</tr>
<tr>
<td>$’</td>
<td>匹配的子字符串之前的子字符串。与RegExp.leftContext的值相同</td>
</tr>
<tr>
<td>$、</td>
<td>匹配的子字符串之后的子字符串。与RegExp.rightContext的值相同</td>
</tr>
<tr>
<td>$n</td>
<td>匹配第n捕获组的子字符串，其中n等于0~9。例如，\$1是匹配第一个捕获组的子字符串，\$2是匹配第二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串</td>
</tr>
<tr>
<td>$nn</td>
<td>匹配第nn个捕获组的子字符串，其中nn等于01~99。例如，\$01是匹配第一个捕获组的子字符串，\$02是匹配第二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串</td>
</tr>
</tbody>
</table>
<p>replace()方法的第二个参数也可以是一个函数。在只有一个匹配项（即与模式匹配的字符串）的情况下，会向这个函数传递3个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项……，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始字符串。这个函数应该返回一个字符串，表示应该被替换的匹配项使用函数作为replace()方法的第二个参数可以实现更加精细的替换操作。</p>
<h4 id="localeCompare-方法"><a href="#localeCompare-方法" class="headerlink" title="localeCompare()方法"></a>localeCompare()方法</h4><p>这个方法比较两个字符串，并返回下列值中的一个</p>
<ul>
<li>如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1，具体的值要视实现而定）</li>
<li>如果字符串等于字符串参数，则返回0</li>
<li>如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是1，具体的值同样要视实现而定）</li>
</ul>
<blockquote>
<p>localeCompare()方法比较与众不同的地方，就是实现所支持的地区（国家和语言）决定了这个方法的行为。比如，美国以英语作为ECMAScript实现的标准语言，因此localeCompare()就是区分大小写的，于是大写字母在字母表中排在小写字母前头就成为了一项决定性的比较规则。不过，在其他地区恐怕就不是这种情况了。</p>
</blockquote>
<h4 id="fromCharCode-方法"><a href="#fromCharCode-方法" class="headerlink" title="fromCharCode()方法"></a>fromCharCode()方法</h4><p>这个方法的任务是接收一或多个字符编码，然后将它们转换成一个字符串。从本质上来看，这个方法与实例方法charCodeAt()执行的是相反的操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(<span class="built_in">String</span>.fromCharCode(<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>)); <span class="comment">//"hello"</span></div></pre></td></tr></table></figure>
<h4 id="HTML方法"><a href="#HTML方法" class="headerlink" title="HTML方法"></a>HTML方法</h4><p>早期的Web浏览器提供商觉察到了使用JavaScript动态格式化HTML的需求。于是，这些提供商就扩展了标准，实现了一些专门用于简化常见HTML格式化任务的方法。下表列出了这些HTML方法。不过，需要请读者注意的是，应该尽量不使用这些方法，因为它们创建的标记通常无法表达语义。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">anchor（name） <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span> = <span class="string">"name"</span>&gt;</span>string<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">big() <span class="tag">&lt;<span class="name">big</span>&gt;</span>string<span class="tag">&lt;/<span class="name">big</span>&gt;</span> </div><div class="line">bold() <span class="tag">&lt;<span class="name">b</span>&gt;</span>string<span class="tag">&lt;/<span class="name">b</span>&gt;</span></div><div class="line">fixed() <span class="tag">&lt;<span class="name">tt</span>&gt;</span>string<span class="tag">&lt;/<span class="name">tt</span>&gt;</span></div><div class="line">fontcolor（color） <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"color"</span>&gt;</span>string<span class="tag">&lt;/<span class="name">font</span>&gt;</span> </div><div class="line">fontsize（size） <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">"size"</span>&gt;</span>string<span class="tag">&lt;/<span class="name">font</span>&gt;</span> </div><div class="line">italics() <span class="tag">&lt;<span class="name">i</span>&gt;</span>string<span class="tag">&lt;/<span class="name">i</span>&gt;</span> </div><div class="line">link（url） <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">“url</span>"&gt;</span>string<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </div><div class="line">small() <span class="tag">&lt;<span class="name">small</span>&gt;</span>string<span class="tag">&lt;/<span class="name">small</span>&gt;</span> </div><div class="line">strike() <span class="tag">&lt;<span class="name">strike</span>&gt;</span>string<span class="tag">&lt;/<span class="name">strike</span>&gt;</span> </div><div class="line">sub() <span class="tag">&lt;<span class="name">sub</span>&gt;</span>string<span class="tag">&lt;/<span class="name">sub</span>&gt;</span> </div><div class="line">sup() <span class="tag">&lt;<span class="name">sup</span>&gt;</span>string<span class="tag">&lt;/<span class="name">sup</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h2><p>ECMA-262对内置对象的定义是：“由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。”意思就是说，开发人员不必显式地实例化内置对象，因为它们已经实例化了。前面我们已经介绍了大多数内置对象，例如Object、Array和String。ECMA-262还定义了两个单体内置对象：Global和Math。</p>
<h3 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h3><p>Global（全局）对象可以说是ECMAScript中最特别的一个对象了，因为不管你从什么角度上看，这个对象都是不存在的。ECMAScript中的Global对象在某种意义上是作为一个终极的“兜底儿对象”来定义的。换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是Global对象的属性。本书前面介绍过的那些函数，诸如isNaN()、isFinite()、parseInt()以及parseFloat()，实际上全都是Global对象的方法。除此之外，Global对象还包含其他一些方法。</p>
<h4 id="URI编码方法"><a href="#URI编码方法" class="headerlink" title="URI编码方法"></a>URI编码方法</h4><p>Global对象的encodeURI()和encodeURIComponent()方法可以对URI（ Uniform Resource Identifiers，通用资源标识符）进行编码，以便发送给浏览器。有效的URI中不能包含某些字符，例如空格。而这两个URI编码方法就可以对URI进行编码，它们用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。</p>
<ul>
<li><code>encodeURI()</code><br>主要用于整个URI（例如，<code>http://www.wrox.com/illegal value.html</code>）</li>
<li><code>encodeURIComponent()</code><br>主要用于对URI中的某一段（例如前面URI中的illegal value.html）进行编码。</li>
</ul>
<p>它们的主要区别在于，encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。</p>
<ul>
<li><code>decodeURI()</code><br>与encodeURI()对应</li>
<li><code>decodeURIComponent()</code><br>与encodeURIComponent()对应</li>
</ul>
<h4 id="eval-方法"><a href="#eval-方法" class="headerlink" title="eval()方法"></a>eval()方法</h4><p>eval()方法就像是一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript（或JavaScript）字符串。看下面的例子：</p>
<p><code>eval(&quot;alert(&#39;hi&#39;)&quot;)</code></p>
<p>这行代码的作用等价于下面这行代码：</p>
<p><code>alert(&quot;hi&quot;)；</code></p>
<p>当解析器发现代码中调用eval()方法时，它会将传入的参数当作实际的ECMAScript语句来解析，然后把执行结果插入到原位置。通过eval()执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链。这意味着通过eval()执行的代码可以引用在包含环境中定义的变量。</p>
<blockquote>
<p>在eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；它们只在eval()执行的时候创建。</p>
<p>严格模式下，在外部访问不到eval()中创建的任何变量或函数</p>
</blockquote>
<h4 id="Global对象的属性"><a href="#Global对象的属性" class="headerlink" title="Global对象的属性"></a>Global对象的属性</h4><table>
<thead>
<tr>
<th>属性</th>
</tr>
</thead>
<tbody>
<tr>
<td>undefined</td>
</tr>
<tr>
<td>NaN</td>
</tr>
<tr>
<td>Infinity</td>
</tr>
<tr>
<td>Object</td>
</tr>
<tr>
<td>Array</td>
</tr>
<tr>
<td>Function</td>
</tr>
<tr>
<td>Boolean</td>
</tr>
<tr>
<td>String</td>
</tr>
<tr>
<td>Numner</td>
</tr>
<tr>
<td>Date</td>
</tr>
<tr>
<td>RegExp</td>
</tr>
<tr>
<td>Error</td>
</tr>
<tr>
<td>EvalError</td>
</tr>
<tr>
<td>RangeError</td>
</tr>
<tr>
<td>ReferenceError</td>
</tr>
<tr>
<td>SyntaxError</td>
</tr>
<tr>
<td>TypeError</td>
</tr>
<tr>
<td>URIError</td>
</tr>
</tbody>
</table>
<h4 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h4><p>ECMAScript虽然没有指出如何直接访问Global对象，但Web浏览器都是将这个全局对象作为window对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了window对象的属性。</p>
<h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><ul>
<li>Math.E</li>
<li>Math.LN10</li>
<li>Math.LN2</li>
<li>Math.LOG2E</li>
<li>Math.PI</li>
<li>Math.SQRT1_2</li>
<li>Math.SQRT2</li>
</ul>
<h4 id="main-和max-方法"><a href="#main-和max-方法" class="headerlink" title="main()和max()方法"></a>main()和max()方法</h4><p>min()和max()方法用于确定一组数值中的最小值和最大值。这两个方法都可以接收任意多个数值参数。</p>
<blockquote>
<p>要找到数组中的最大或最小值，可以像下面这样使用apply()方法。</p>
<p>var values = [1, 2, 3, 4];<br>var max = Math.max.apply(Math, values);</p>
</blockquote>
<h4 id="舍入方法"><a href="#舍入方法" class="headerlink" title="舍入方法"></a>舍入方法</h4><ul>
<li><code>Math.ceil()</code><br>Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数</li>
<li><code>Math.floor()</code><br>Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数</li>
<li><code>Math.round()</code><br>Math.round()执行标准舍入，即它总是将数值四舍五人为最接近的整数（这也是我们在数学课上学到的舍入规则</li>
</ul>
<h4 id="random-方法"><a href="#random-方法" class="headerlink" title="random()方法"></a>random()方法</h4><p>Math.random()方法返回介于0和1之间一个随机数，不包括0和1。</p>
<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><table>
<thead>
<tr>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>abs(num)</td>
</tr>
<tr>
<td>exp(num)</td>
</tr>
<tr>
<td>log(num)</td>
</tr>
<tr>
<td>pow(num,power)</td>
</tr>
<tr>
<td>sqrt(num)</td>
</tr>
<tr>
<td>acos(x)</td>
</tr>
<tr>
<td>asin(x)</td>
</tr>
<tr>
<td>atan(x)</td>
</tr>
<tr>
<td>atan2(y,x)</td>
</tr>
<tr>
<td>cos(x)</td>
</tr>
<tr>
<td>sin(x)</td>
</tr>
<tr>
<td>tan(x)</td>
</tr>
</tbody>
</table>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>引用类型与传统面向对象程序设计中的类相似，但实现不同；</li>
<li>Object是一个基础类型，其他所有类型都从Object继承了基本的行为；</li>
<li>Array类型是一组值的有序列表，同时还提供了操作和转换这些值的功能；</li>
<li>Date类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能；</li>
<li>RegExp类型是ECMAScript支持正则表达式的一个接口，提供了最基本的和一些高级的正则表达式功能。<br>函数实际上是Function类型的实例，因此函数也是对象；而这一点正是JavaScript最有特色的地方。由于函数是对象，所以函数也拥有方法，可以用来增强其行为。</li>
</ul>
<p>因为有了基本包装类型，所以JavaScript中的基本类型值可以被当作对象来访问。三种基本包装类型分别是：Boolean、Number和String。以下是它们共同的特征：</p>
<ul>
<li>每个包装类型都映射到同名的基本类型；</li>
<li>在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据操作；</li>
<li>操作基本类型值的语句一经执行完毕，就会立即销毁新创建的包装对象。</li>
</ul>
<p>在所有代码执行之前，作用域中就已经存在两个内置对象：Global和Math。在大多数ECMAScript实现中都不能直接访问Global对象；不过，Web浏览器实现了承担该角色的window对象。全局变量和函数都是Global对象的属性。Math对象提供了很多属性和方法，用于辅助完成复杂的数学计算任务。</p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/javascript/" rel="tag">#javascript</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/08/05/JavaScript的变量、作用域和内存问题/" rel="next" title="JavaScript的变量、作用域和内存问题">
                <i class="fa fa-chevron-left"></i> JavaScript的变量、作用域和内存问题
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/08/15/JavaScript面向对象的程序设计/" rel="prev" title="JavaScript面向对象的程序设计">
                JavaScript面向对象的程序设计 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- Go to www.addthis.com/dashboard to customize your tools -->
<script type = "text/javascript" src = "//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-59618c19beb4fcfa" async = "async" ></script>
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="Lisiur Day" />
          <p class="site-author-name" itemprop="name">Lisiur Day</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">35</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Object类型"><span class="nav-number">1.</span> <span class="nav-text">Object类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Array类型"><span class="nav-number">2.</span> <span class="nav-text">Array类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#检测数组"><span class="nav-number">2.1.</span> <span class="nav-text">检测数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转换方法"><span class="nav-number">2.2.</span> <span class="nav-text">转换方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈方法"><span class="nav-number">2.3.</span> <span class="nav-text">栈方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#队列方法"><span class="nav-number">2.4.</span> <span class="nav-text">队列方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重排序方法"><span class="nav-number">2.5.</span> <span class="nav-text">重排序方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作方法"><span class="nav-number">2.6.</span> <span class="nav-text">操作方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#位置方法"><span class="nav-number">2.7.</span> <span class="nav-text">位置方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代方法"><span class="nav-number">2.8.</span> <span class="nav-text">迭代方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缩小方法"><span class="nav-number">2.9.</span> <span class="nav-text">缩小方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Date类型"><span class="nav-number">3.</span> <span class="nav-text">Date类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#继承的方法"><span class="nav-number">3.1.</span> <span class="nav-text">继承的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#日期格式化方法"><span class="nav-number">3.2.</span> <span class="nav-text">日期格式化方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#日期-时间组件方法"><span class="nav-number">3.3.</span> <span class="nav-text">日期/时间组件方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RegExp类型"><span class="nav-number">4.</span> <span class="nav-text">RegExp类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RegExp实例属性"><span class="nav-number">4.1.</span> <span class="nav-text">RegExp实例属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RegExp实例方法"><span class="nav-number">4.2.</span> <span class="nav-text">RegExp实例方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RegExp构造函数属性"><span class="nav-number">4.3.</span> <span class="nav-text">RegExp构造函数属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模式的局限性"><span class="nav-number">4.4.</span> <span class="nav-text">模式的局限性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Function类型"><span class="nav-number">5.</span> <span class="nav-text">Function类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#没有重载"><span class="nav-number">5.1.</span> <span class="nav-text">没有重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数声明与函数表达式"><span class="nav-number">5.2.</span> <span class="nav-text">函数声明与函数表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作为值的函数"><span class="nav-number">5.3.</span> <span class="nav-text">作为值的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数内部属性"><span class="nav-number">5.4.</span> <span class="nav-text">函数内部属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数属性和方法"><span class="nav-number">5.5.</span> <span class="nav-text">函数属性和方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#属性"><span class="nav-number">5.5.1.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法"><span class="nav-number">5.5.2.</span> <span class="nav-text">方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本包装类型"><span class="nav-number">6.</span> <span class="nav-text">基本包装类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Boolean类型"><span class="nav-number">6.1.</span> <span class="nav-text">Boolean类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Number类型"><span class="nav-number">6.2.</span> <span class="nav-text">Number类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String类型"><span class="nav-number">6.3.</span> <span class="nav-text">String类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#字符方法"><span class="nav-number">6.3.1.</span> <span class="nav-text">字符方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串方法"><span class="nav-number">6.3.2.</span> <span class="nav-text">字符串方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串位置方法"><span class="nav-number">6.3.3.</span> <span class="nav-text">字符串位置方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#trim-方法"><span class="nav-number">6.3.4.</span> <span class="nav-text">trim()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串大小转换方法"><span class="nav-number">6.3.5.</span> <span class="nav-text">字符串大小转换方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串的模式匹配方法"><span class="nav-number">6.3.6.</span> <span class="nav-text">字符串的模式匹配方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#localeCompare-方法"><span class="nav-number">6.3.7.</span> <span class="nav-text">localeCompare()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fromCharCode-方法"><span class="nav-number">6.3.8.</span> <span class="nav-text">fromCharCode()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTML方法"><span class="nav-number">6.3.9.</span> <span class="nav-text">HTML方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单体内置对象"><span class="nav-number">7.</span> <span class="nav-text">单体内置对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Global对象"><span class="nav-number">7.1.</span> <span class="nav-text">Global对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#URI编码方法"><span class="nav-number">7.1.1.</span> <span class="nav-text">URI编码方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#eval-方法"><span class="nav-number">7.1.2.</span> <span class="nav-text">eval()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Global对象的属性"><span class="nav-number">7.1.3.</span> <span class="nav-text">Global对象的属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#window对象"><span class="nav-number">7.1.4.</span> <span class="nav-text">window对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Math对象"><span class="nav-number">7.2.</span> <span class="nav-text">Math对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#属性-1"><span class="nav-number">7.2.1.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#main-和max-方法"><span class="nav-number">7.2.2.</span> <span class="nav-text">main()和max()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#舍入方法"><span class="nav-number">7.2.3.</span> <span class="nav-text">舍入方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#random-方法"><span class="nav-number">7.2.4.</span> <span class="nav-text">random()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他方法"><span class="nav-number">7.2.5.</span> <span class="nav-text">其他方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">8.</span> <span class="nav-text">小结</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lisiur Day</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'lisiur';
      var disqus_identifier = '2016/08/10/JavaScript引用类型/';
      var disqus_title = 'JavaScript引用类型';
      var disqus_url = 'http://Lisiur.com/2016/08/10/JavaScript引用类型/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  



  
  
  

  

  

</body>
</html>
