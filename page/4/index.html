<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Lisiur" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Lisiur">
<meta property="og:url" content="http://Lisiur.com/page/4/index.html">
<meta property="og:site_name" content="Lisiur">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lisiur">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Lisiur </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Lisiur</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/10/JavaScript引用类型/" itemprop="url">
                  JavaScript引用类型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-10T10:28:55+08:00" content="2016-08-10">
              2016-08-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/javascript笔记/" itemprop="url" rel="index">
                    <span itemprop="name">javascript笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><p>到目前为止，我们看到的大多数引用类型值都是Object类型的实例；而且，Object也是ECMAScript中使用最多的一个类型。虽然Object的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。</p>
<p>创建Object实例的方式有两种。</p>
<ol>
<li>第一种是使用new操作符后跟Object构造函数。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">person.name = <span class="string">"Nicholas"</span>;</div><div class="line">person.age = <span class="number">20</span>;</div></pre></td></tr></table></figure>
<ol>
<li>另一种方式是使用对象字面量表示法。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">	<span class="attr">name</span> : <span class="string">"Nicholas"</span>,</div><div class="line">	<span class="attr">age</span> : <span class="number">29</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h2><p>ECMAScript数组的每一项可以保存任何类型的数据。<br>创建数组的基本方式有两种。</p>
<ol>
<li>第一种是使用Array构造函数。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>()；</div><div class="line"></div><div class="line"><span class="comment">// 如果预先知道数组要保存的项目数量，也可以给构造函数传递该数量，而该数量会自动变成length属性的值。例如，下面的代码将创建length值为20的数组。</span></div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>（<span class="number">20</span>;</div><div class="line"></div><div class="line"><span class="comment">// 也可以向Array构造函数传递数组中应该包含的项。以下代码创建了一个包含3个字符串值的数组：</span></div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>（<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>）；</div><div class="line"></div><div class="line"><span class="comment">//当然，给构造函数传递一个值也可以创建数组。但这时候问题就复杂一点了，因为如果传递的是数值，则会按照该数值创建包含给定项数的数组；而如果传递的是其他类型的参数，则会创建包含那个值的只有一项的数组。</span></div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">// 创建一个包含三项的数组</span></div><div class="line"><span class="keyword">var</span> names = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"Greg"</span>); <span class="comment">// 创建一个包含1项， 即字符串“Greg”的数组</span></div></pre></td></tr></table></figure>
<ol>
<li>创建数组的第二种基本方式是使用数组字面量表示法。数组字面量由一对包含数组项的方括号表示，多个数组项之间以逗号隔开。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含三个字符串的数组</span></div><div class="line"><span class="keyword">var</span> names = []; <span class="comment">// 创建一个空数组</span></div><div class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,]; <span class="comment">// 不要这样！IE中为[1,2,undefined],其他为[1,2]</span></div><div class="line"><span class="keyword">var</span> options = [,,,,,]; <span class="comment">// 不要这样！</span></div></pre></td></tr></table></figure>
<p>在读取和设置数组的值时，要使用方括号并提供相应值的基于0的数字索引。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; </div><div class="line">alert(colors[<span class="number">0</span>]); <span class="comment">//显示第一项</span></div><div class="line">colors[<span class="number">2</span>] = <span class="string">"black"</span>; <span class="comment">// 修改第三项</span></div><div class="line">colors[<span class="number">3</span>] = <span class="string">"brown"</span>; <span class="comment">// 新增第四项</span></div></pre></td></tr></table></figure>
<p>数组的项数保存在其length属性中，这个属性始终会返回0或更大的值。</p>
<p>数组的length属性很有特点——它不是只读的。因此，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">colors.length = <span class="number">2</span>;</div><div class="line">alert([colors[<span class="number">2</span>]]); <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<blockquote>
<p>数组最多可以包含4 294 967 295个项，这几乎已经能够满足任何编程需求了。如果想添加的项数超过这个上限值，就会发生异常。而创建一个初始大小与这个上限值接近的数组，则可能会导致运行时间超长的脚本错误。</p>
</blockquote>
<h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><p>正常情况下<strong>instanceof</strong>就可以判断是否为数组。instanceof操作符的问题在于，它假定单一的全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。为了解决这个问题，ECMAScript 5新增了<strong>Array.isArray()</strong>方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。</p>
<blockquote>
<p>支持Array.isAr ray()方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 10.5+和Chrome。</p>
</blockquote>
<h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><p>所有对象都具有toLocaleString()、toString()和valueOf()方法。其中，调用数组的toString()和valueOf()方法会返回相同的值，即由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。实际上，为了创建这个字符串会调用数组每一项的toString()方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">alert(colors.toString()); <span class="comment">// red,blue,green</span></div><div class="line">alert(colors.valueOf()); <span class="comment">// red,blue,green</span></div><div class="line">alert(colors); <span class="comment">// red,blue,green</span></div></pre></td></tr></table></figure>
<p>使用join()方法，则可以使用不同的分隔符来构建这个字符串。join()方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">alert(colors.join(<span class="string">"|"</span>)); <span class="comment">// red|green|blue</span></div></pre></td></tr></table></figure>
<blockquote>
<p>如果不给join()方法传入任何值，或者给它传入undefined，则使用逗号作为分隔符。IE7及更早版本会错误的使用字符串”undefined”作为分隔符。<br>如果数组中的某一项的值是null或者undefined，那么该值在join()、toLocale-String()、toString()和valueOf()方法返回的结果中以空字符串表示。</p>
</blockquote>
<h3 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h3><p>ECMAScript为数组专门提供了<strong>push()</strong>和<strong>pop()</strong>方法，以便实现类似栈的行为。</p>
<p>push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。而pop()方法则从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。</p>
<h3 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h3><p>由于<strong>push()</strong>是向数组末端添加项的方法，因此要模拟队列只需一个从数组前端取得项的方法。实现这一操作的数组方法就是<strong>shift()</strong>，它能够移除数组中的第一个项并返回该项，同时将数组长度减1。结合使用shift()和push()方法，可以像使用队列一样使用数组。</p>
<p>ECMAScript还为数组提供了一个<strong>unshift()</strong>方法。顾名思义，unshift()与shift()的用途相反：它能在数组前端添加任意个项并返回新数组的长度。因此，同时使用unshift()和<strong>pop()</strong>方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项。</p>
<blockquote>
<p>IE7及更早版本对JavaScript的实现中存在一个偏差，其unshift()方法总是返回undefined而不是数组的新长度。IE8在非兼容模式下会返回正确的长度值。</p>
</blockquote>
<h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><ul>
<li><p>reverse()<br>reverse()方法会对反转数组项的顺序。</p>
</li>
<li><p>sort()<br>在默认情况下，sort()方法按升序排列数组项一一即最小的值位于最前面，最大的值排在最后面。为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</div><div class="line">values.sort();</div><div class="line">alert(values); <span class="comment">// 0,1,10,15,5</span></div></pre></td></tr></table></figure>
<p>可见，即使例子中值的顺序没有问题，但sort()方法也会根据测试字符串的结果改变原来的顺序。因为数值5虽然小于10，但在进行字符串比较时，”10”则位于”5”的前面，于是数组的顺序就被修改了。不用说，这种排序方式在很多情况下都不是最佳方案。因此sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。</p>
<p>比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">cmp</span>(<span class="params">value1, value2</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> value1 &lt; value2;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</div><div class="line">values.sort(cmp);</div><div class="line">alert(values); <span class="comment">// 0,1,5,10,15</span></div></pre></td></tr></table></figure>
<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><p>ECMAScript为操作已经包含在数组中的项提供了很多方法。</p>
<ul>
<li>concat()<br>concat()方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给concat()方法传递参数的情况下，它只是复制当前数组并返回副本。如果传递给concat()方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</div><div class="line"><span class="keyword">var</span> colors2 = colors.concat(<span class="string">"yellow"</span>, [<span class="string">"black"</span>, <span class="string">"brown"</span>]);</div><div class="line"></div><div class="line">alert(colors);  <span class="comment">// red,green,blue</span></div><div class="line">alert(colors2); <span class="comment">// red,green,blue,yellow,black,brown</span></div></pre></td></tr></table></figure>
<ul>
<li>slice()<br>能够基于当前数组中的一或多个项创建一个新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项一一但不包括结束位置的项。注意，slice()方法不会影响原始数组。</li>
</ul>
<blockquote>
<p>如果slice()方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。例如，在一个包含5项的数组上调用slice（-2，-1）与调用slice（3, 4）得到的结果相同。如果结束位置小于起始位置，则返回空数组。</p>
</blockquote>
<ul>
<li>splice()<br>splice()的主要用途是向数组的中部插入项，但使用这种方法的方式则有如下3种。<ul>
<li>删除：可以删除任意数量的项，只需指定2个参数：要删除的第一项的位置和要删除的项数。例如，<code>splice(0，2)</code>会删除数组中的前两项。</li>
<li>插入：可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，<code>splice(2,0, &quot;red&quot;, &quot;green&quot;)</code>会从当前数组的位置2开始插入字符串”red”和”green”。</li>
<li>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，<code>splice(2,1, &quot;red&quot;, &quot;green&quot;)</code>会删除当前数组位置2的项，然后再从位置2开始插入字符串”red”和”green”。</li>
</ul>
</li>
</ul>
<blockquote>
<p>splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。<br>splice在原数组上操作。</p>
</blockquote>
<h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><p>ECMAScript 5为数组实例添加了两个位置方法：<code>indexOf()</code>和<code>lastIndexOf()</code>。这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中，indexOf()方法从数组的开头（位置0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>];</div><div class="line">alert(numbers.indexOf(<span class="number">4</span>)); <span class="comment">// 3</span></div><div class="line">alert(numbers.lastIndexOf(<span class="number">4</span>)); <span class="comment">// 5</span></div><div class="line"></div><div class="line">alert(numbers.indexOf(<span class="number">4</span>,<span class="number">4</span>)); <span class="comment">// 5</span></div><div class="line">alert(numbers.lastIndexOf(<span class="number">4</span>,<span class="number">4</span>)); <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> person = &#123;<span class="attr">name</span>: <span class="string">"lisiur"</span>&#125;;</div><div class="line"><span class="keyword">var</span> people = [&#123;<span class="attr">name</span>: <span class="string">"lisiur"</span>&#125;];</div><div class="line"></div><div class="line"><span class="keyword">var</span> morePeople = [people];</div><div class="line"></div><div class="line">alert(people.indexOf(person)); <span class="comment">// -1</span></div><div class="line">alert(morePeople.indexOf(person)); <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<blockquote>
<p>使用indexOf()和lastIndexOf()方法查找特定项在数组中的位置非常简单，支持它们的浏览器包括IE9+、Firefox 2+、Safari 3+、Opera 9.5+和Chrome。</p>
</blockquote>
<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><p>ECMAScript 5为数组定义了5个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响this的值。传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响访问的返回值。以下是这5个迭代方法的作用。</p>
<ul>
<li><code>every()</code>：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。</li>
<li><code>filter()</code>:对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。</li>
<li><code>forEach()</code>：对数组中的每一项运行给定函数。这个方法没有返回值。</li>
<li><code>map()</code>：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>
<li><code>some()</code>：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。</li>
</ul>
<blockquote>
<p>以上方法都不会修改数组中的包含的值。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// every VS some</span></div><div class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> everyResult = numbers.every(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> (item&gt;<span class="number">2</span>);</div><div class="line">&#125;);</div><div class="line">alert(everyResult); <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> someResult = numbers.some(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> (item &gt; <span class="number">2</span>);</div><div class="line">&#125;);</div><div class="line">alert(someResult); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// filter</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> filterResult = numbersfilter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> (item &gt; <span class="number">2</span>);</div><div class="line">&#125;);</div><div class="line">alert(filterResult); <span class="comment">// [3,4,5,4,3]</span></div><div class="line"></div><div class="line"><span class="comment">// map</span></div><div class="line"><span class="keyword">var</span> mapResult = numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> item*<span class="number">2</span>;</div><div class="line">&#125;);</div><div class="line">alert(mapResult); <span class="comment">// [2,4,6,8,10,8,6,4,2]</span></div><div class="line"></div><div class="line"><span class="comment">// forEach</span></div><div class="line"></div><div class="line">numbers.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</div><div class="line">	<span class="comment">// do something</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>支持这些迭代方法的浏览器有IE9+、Firefox 2+、Safari 3+、Opera 9.5+和Chrome。</p>
</blockquote>
<h3 id="缩小方法"><a href="#缩小方法" class="headerlink" title="缩小方法"></a>缩小方法</h3><p>ECMAScript 5还新增了两个缩小数组的方法：reduce()和reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历到最后。而reduceRight()则从数组的最后一项开始，向前遍历到第一项。</p>
<p>这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为缩小基础的初始值。传给reduce()和reduceRight()的函数接收4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。</p>
<p>使用reduce()方法可以执行求数组中所有值之和的操作，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> sum = value.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> prev + cur;</div><div class="line">&#125;);</div><div class="line">alert(sum); <span class="comment">// 15</span></div></pre></td></tr></table></figure>
<p>reduceRight()的作用类似，只不过方向相反而已。</p>
<blockquote>
<p>持这两个缩小函数的浏览器有IE9+、Firefox 3+、Safari 4+、Opera 10.5和Chrome。</p>
</blockquote>
<h2 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h2><p>要创建一个日期对象，使用new操作符和Date构造函数即可</p>
<p><code>var now = new Date()</code></p>
<p>在调用Date构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数（即从UTC时间1970年1月1日午夜起至该日期止经过的毫秒数）。为了简化这一计算过程，ECMAScript提供了两个方法：Date.parse()和Date.UTC()。</p>
<p>其中，Date.parse()方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。ECMA-262没有定义Date.parse()应该支持哪种日期格式，因此这个方法的行为因实现而异，而且通常是因地区而异。将地区设置为美国的浏览器通常都接受下列日期格式：</p>
<ul>
<li>“月/日/年”，如6/13/2004;</li>
<li>“英文月名日，年”，如January12，2004;</li>
<li>“英文星期几英文月名日年时：分：秒时区”，如Tue May 25 2004 00:00:00 GMT-0700。</li>
<li>ISO 8601扩展格式YYYY-MM-DDTHH:mm:ss.sssZ（例如2004-05-25T00:00:00）。只有兼容ECMAScript 5的实现支持这种格式。</li>
</ul>
<p>例如，要为2004年5月25日创建一个日期对象，可以使用下面的代码:</p>
<p><code>var someDate = new Date(Date.parse(&quot;May 25, 2004&quot;));</code></p>
<p>如果传入Date.parse()方法的字符串不能表示日期，那么它会返回NaN。实际上，如果直接将表示日期的字符串传递给Date构造函数，也会在后台调用Date.parse()。换句话说，下面的代码与前面的例子是等价的：</p>
<p><code>var someDate = new Date(&quot;May 25, 2004&quot;);</code></p>
<p>这行代码将会得到与前面相同的日期对象。</p>
<blockquote>
<p>日期对象及其在不同浏览器中的实现有许多奇怪的行为。其中有一种倾向是将超出范围的值替换成当前的值，以便生成输出。例如，在解析”January 32, 2007”时，有的浏览器会将其解释为”February 1, 2007”。而Opera则倾向于插入当前月份的当前日期，返回”January当前日期，2007”。也就是说，如果在2007年9月21日运行前面的代码，将会得到”January 21, 2007”（都是21日）。</p>
</blockquote>
<p>Date.UTC()方法同样也返回表示日期的毫秒数，但它与Date.parse()在构建值时使用不同的信息。Date.UTC()的参数分别是年份、基于0的月份（一月是0，二月是1，以此类推）、月中的哪一天（1到31）、小时数（0到23）、分钟、秒以及毫秒数。在这些参数中，只有前两个参数（年和月）是必需的。如果没有提供月中的天数，则假设天数为1；如果省略其他参数，则统统假设为0。以下是两个使用Date.UTC()方法的例子：</p>
<p>GMT时间2000年1月1日午夜零时：<br><code>var y2k = new Date(Date.UTC(2000, 0));</code><br>GMT时间2005年5月5日下午5:55:55：<br><code>var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));</code></p>
<p>如同模仿Date.parse()一样，Date构造函数也会模仿Date.UTC()，但有一点明显不同：日期和时间都基于本地时区而非GMT来创建。不过，Date构造函数接收的参数仍然与Date.UTC()相同。因此，如果第一个参数是数值，Date构造函数就会假设该值是日期中的年份，而第二个参数是月份，以此类推。</p>
<p>本地时间2000年1月1日午夜零时：<br><code>var y2k = new Date(2000, 0);</code><br>本地时间2005年5月5日下午5:55:55：<br><code>var allFives = new Date(2005, 4, 5, 17, 55, 55);</code></p>
<p>ECMAScript 5添加了Data.now()方法，返回表示调用这个方法时的日期和时间的毫秒数。这个方法简化了使用Data对象分析代码的工作。</p>
<p><code>var start = Date.now()</code></p>
<blockquote>
<p>支持Data.now()方法的浏览器包括IE9+、Firefox 3+、Safari 3+、Opera 10.5和Chrome。在不支持它的浏览器中，使用+操作符把Data对象转换成字符串，也可以达到同样的目的。</p>
</blockquote>
<h3 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h3><p>与其他引用类型一样，Date类型也重写了toLocaleString()、toString()和valueOf()方法；但这些方法(toLocaleString()、toString())回的值与其他类型中的方法不同。<br>Date类型的toLocaleString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间。这大致意味着时间格式中会包含AM或PM，但不会包含时区信息（当然，具体的格式会因浏览器而异）。而toString()方法则通常返回带有时区信息的日期和时间，其中时间一般以军用时间（即小时的范围是0到23）表示。</p>
<blockquote>
<p>这两个方法在不同的浏览器中返回的日期和时间格式可谓大相径庭。事实上，toLocaleString()和toString()的这一差别仅在调试代码时比较有用，而在显示日期和时间时没有什么价值。</p>
<p>至于Date类型的valueOf()方法，则根本不返回字符串，而是返回日期的毫秒表示。因此，可以方便使用比较操作符（小于或大于）来比较日期值。</p>
</blockquote>
<h3 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h3><p>Date类型还有一些专门用于将日期格式化为字符串的方法，这些方法如下。</p>
<ul>
<li>toDateString()——以特定于实现的格式显示星期几、月、日和年；</li>
<li>toTimeString()——以特定于实现的格式显示时、分、秒和时区；</li>
<li>toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年；</li>
<li>toLocaleTimeString()——以特定于实现的格式显示时、分、秒；</li>
<li>toUTCString()——以特定于实现的格式完整的UTC日期。</li>
</ul>
<blockquote>
<p>与toLocaleString()和toString()方法一样，以上这些字符串格式方法的输出也是因浏览器而异的，因此没有哪一个方法能够用来在用户界面中显示一致的日期信息。</p>
</blockquote>
<h3 id="日期-时间组件方法"><a href="#日期-时间组件方法" class="headerlink" title="日期/时间组件方法"></a>日期/时间组件方法</h3><ul>
<li><code>getTime()</code><br>返回表示日期的毫秒数；与valueOf()方法返回的值相同 </li>
<li><code>setTime(毫秒)</code><br>以毫秒数设置日期，会改变整个日期 </li>
<li><code>getFullYear()</code><br>取得4位数的年份（如2007而非仅07） </li>
<li><code>getUTCFullYear()</code><br>返回UTC日期的4位数年份 </li>
<li><code>setFullYear(年)</code><br>设置日期的年份。传入的年份值必须是4位数字（如2007而非仅07） </li>
<li><code>setUTCFullYear(年)</code><br>设置UTC日期的年份。传入的年份值必须是4位数字（如2007而非仅07） </li>
<li><code>getMonth()</code><br>返回日期中的月份，其中0表示一月，11表示十二月 </li>
<li><code>getUTCMonth()</code><br>返回UTC日期中的月份，其中0表示一月，11表示十二月 </li>
<li><code>setMonth(月)</code><br>设置日期的月份。传入的月份值必须大于0，超过11则增加年份 </li>
<li><code>setUTCMonth(月)</code><br>设置UTC日期的月份。传入的月份值必须大于0，超过11则增加年份 </li>
<li><code>getDate()</code><br>返回日期月份中的天数（1到31） </li>
<li><code>getUTCDate()</code><br>返回UTC日期月份中的天数（1到31） </li>
<li><code>setDate(日)</code><br>设置日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份 </li>
<li><code>setUTCDate(日)</code><br>设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份 </li>
<li><code>getDay()</code><br>返回日期中星期的星期几（其中0表示星期日，6表示星期六） </li>
<li><code>getUTCDay()</code><br>返回UTC日期中星期的星期几（其中0表示星期日，6表示星期六） </li>
<li><code>getHours()</code><br>返回日期中的小时数（0到23） </li>
<li><code>getUTCHours()</code><br>返回UTC日期中的小时数（0到23） </li>
<li><code>setHours(时)</code><br>设置日期中的小时数。传入的值超过了23则增加月份中的天数 </li>
<li><code>setUTCHours(时)</code><br>设置UTC日期中的小时数。传入的值超过了23则增加月份中的天数 </li>
<li><code>getMinutes()</code><br>返回日期中的分钟数（0到59） </li>
<li><code>getUTCMinutes()</code><br>返回UTC日期中的分钟数（0到59） </li>
<li><code>setMinutes(分)</code><br>设置日期中的分钟数。传入的值超过59则增加小时数 </li>
<li><code>setUTCMinutes(分)</code><br>设置UTC日期中的分钟数。传入的值超过59则增加小时数 </li>
<li><code>getSeconds()</code><br>返回日期中的秒数（0到59） </li>
<li><code>getUTCSeconds()</code><br>返回UTC日期中的秒数（0到59） </li>
<li><code>setSeconds(秒)</code><br>设置日期中的秒数。传入的值超过了59会增加分钟数 </li>
<li><code>setUTCSeconds(秒)</code><br>设置UTC日期中的秒数。传入的值超过了59会增加分钟数 </li>
<li><code>getMilliseconds()</code><br>返回日期中的毫秒数 </li>
<li><code>getUTCMilliseconds()</code><br>返回UTC日期中的毫秒数 </li>
<li><code>setMilliseconds(毫秒)</code><br>设置日期中的毫秒数 </li>
<li><code>setUTCMilliseconds(毫秒)</code><br>设置UTC日期中的毫秒数 </li>
<li><code>getTimezoneOffset()</code><br>返回本地时间与UTC时间相差的分钟数。例如，美国东部标准时间返回300。在某地进入夏令时的情况下，这个值会有所变化</li>
</ul>
<h2 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h2><p>ECMAScript通过RegExp类型来支持正则表达式。</p>
<p><code>var expression = /pattern/falgs</code></p>
<p>其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。正则表达式的匹配模式支持下列3个标志。</p>
<ul>
<li>g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；</li>
<li>i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；</li>
<li>m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。</li>
</ul>
<p>因此，一个正则表达式就是一个模式与上述3个标志的组合体。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 匹配字符串中所有"at"的实例</div><div class="line"> * /</div><div class="line">var pattern1 = /at/g;</div><div class="line"></div><div class="line">/*</div><div class="line"> * 匹配第一个"bat"或"cat",不区分大小写</div><div class="line"> * /</div><div class="line">var pattern2 = /[bc]at/i;</div><div class="line"></div><div class="line">/*</div><div class="line"> * 匹配所有以"at"结尾的3个字符的组合，不区分大小写</div><div class="line"> * /</div><div class="line">var pattern3 = /.at/gi;</div></pre></td></tr></table></figure>
<p>与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：<br><code>( ) [ ] { } \ | ^ $ ? * + .</code></p>
<p>另一种创建正则表达式的方式是使用RegExp构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。可以使用字面量定义的任何表达式，都可以使用构造函数来定义:</p>
<p><code>var pattern = new RegExp(&quot;[bc]at&quot;, &quot;i&quot;);</code></p>
<blockquote>
<p>要注意的是，传递给RegExp构造函数的两个参数都是字符串（不能把正则表达式字面量传递给RegExp构造函数）。</p>
</blockquote>
<p>由于RegExp构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此，例如\n（字符\在字符串中通常被转义为\，而在正则表达式字符串中就会变成\\）。下表给出了一些模式，左边是这些模式的字面量形式，右边是使用RegExp构造函数定义相同模式时使用的字符串。</p>
<table>
<thead>
<tr>
<th>字面量模式</th>
<th>等价的字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>/[bc]at/</td>
<td>“\[bc\]at”</td>
</tr>
<tr>
<td>/.at/</td>
<td>“\.at”</td>
</tr>
<tr>
<td>/name\/age/</td>
<td>“name\/age”</td>
</tr>
<tr>
<td>/\d.\d{l,2}/</td>
<td>“\d.\d[l,2}”</td>
</tr>
<tr>
<td>/\w\hello\123/</td>
<td>“\w\\hello\\123”</td>
</tr>
</tbody>
</table>
<p>使用正则表达式字面量和使用RegExp构造函数创建的正则表达式不一样。在ECMAScript 3中，正则表达式字面量始终会共享同一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例。</p>
<h3 id="RegExp实例属性"><a href="#RegExp实例属性" class="headerlink" title="RegExp实例属性"></a>RegExp实例属性</h3><p>RegExp的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。</p>
<ul>
<li>global:布尔值，表示是否设置了g标志。</li>
<li>ignoreCase:布尔值，表示是否设置了i标志。</li>
<li>lastIndex:整数，表示开始搜索下一个匹配项的字符位置，从0算起。</li>
<li>multiline:布尔值，表示是否设置了m标志。</li>
<li>source:正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。</li>
</ul>
<h3 id="RegExp实例方法"><a href="#RegExp实例方法" class="headerlink" title="RegExp实例方法"></a>RegExp实例方法</h3><ul>
<li>exec()<br>RegExp对象的主要方法是exec()，该方法是专门为捕获组而设计的。exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null。返回的数组虽然是Array的实例，但包含两个额外的属性：index和input。其中，index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"mom and dad and baby"</span>;</div><div class="line"><span class="keyword">var</span> pattern = <span class="regexp">/mom( and dad( and baby)?)?/gi</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> matches = pattern.exec(text);</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * [ 'mom and dad and baby',</div><div class="line"> *   ' and dad and baby',</div><div class="line"> *   ' and baby',</div><div class="line"> *   index: 0,</div><div class="line"> *   input: 'mom and dad and baby' ]</div><div class="line"> */</div></pre></td></tr></table></figure>
<p>对于exec()方法而言，即使在模式中设置了全局标志（g），它每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项</p>
<ul>
<li>test()<br>正则表达式的第二个方法是test()，它接受一个字符串参数。在模式与该参数匹配的情况下返回true；否则，返回false。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便。因此，test()方法经常被用在if语句中。</li>
</ul>
<blockquote>
<p>RegExp实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量，与创建正则表达式的方式无关。</p>
<p>正则表达式的valueOf()方法返回正则表达式本身。</p>
</blockquote>
<h3 id="RegExp构造函数属性"><a href="#RegExp构造函数属性" class="headerlink" title="RegExp构造函数属性"></a>RegExp构造函数属性</h3><p>RegExp构造函数包含一些属性（这些属性在其他语言中被看成是静态属性）。这些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。关于这些属性的另一个独特之处，就是可以通过两种方式访问它们。换句话说，这些属性分别有一个长属性名和一个短属性名（Opera是例外，它不支持短属性名）。下表列出了RegExp构造函数的属性。</p>
<table>
<thead>
<tr>
<th>长属性名</th>
<th>短属性名</th>
<th>说明               </th>
</tr>
</thead>
<tbody>
<tr>
<td>input</td>
<td>$_</td>
<td>最近一次要匹配的字符串。Opera未实现此属性。</td>
</tr>
<tr>
<td>lastMatch</td>
<td>$&amp;</td>
<td>最近一次的匹配项。Opera未实现此属性。</td>
</tr>
<tr>
<td>lastParen</td>
<td>$+</td>
<td>最近一次匹配的捕获组。Opera未实现此属性</td>
</tr>
<tr>
<td>leftContext</td>
<td>$`</td>
<td>input字符串中lastMatch之前的文本。</td>
</tr>
<tr>
<td>multiline</td>
<td>$*</td>
<td>布尔值，表示是否所有表达式都使用多行模式。IE和Opera未实现此属性</td>
</tr>
<tr>
<td>rightContext</td>
<td>$’</td>
<td>Input字符串中lastMatch之后的文本。</td>
</tr>
</tbody>
</table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"this has been a short summer"</span>;</div><div class="line"><span class="keyword">var</span> pattern = <span class="regexp">/(.)hort/g</span>;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Opera 不支持 input, lastMatch, lastParen, multiline</div><div class="line"> * IE    不支持 multiline</div><div class="line"> * /</div><div class="line"></div><div class="line">if (pattern.test(text)) &#123;</div><div class="line">	alert(RegExp.input);  // this has been a short summer</div><div class="line">	alert(RegExp.leftContext);  // this has been a</div><div class="line">	alert(RegExp.rightContext); // summer</div><div class="line">	alert(RegExp.lastMatch); // short</div><div class="line">	alert(RegExp.lastParen); // s</div><div class="line">	alert(RegExp.multiline); // false</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了上面介绍的几个属性之外，还有多达9个用于存储捕获组的构造函数属性。访问这些属性的语法是<code>RegExp.$1</code>、<code>RegExp.$2</code>…<code>RegExp.$9</code>，分别用于存储第一、第二……第九个匹配的捕获组。在调用exec()或test()方法时，这些属性会被自动填充。</p>
<h3 id="模式的局限性"><a href="#模式的局限性" class="headerlink" title="模式的局限性"></a>模式的局限性</h3><p>尽管ECMAScript中的正则表达式功能还是比较完备的，但仍然缺少某些语言（特别是Perl）所支持的高级正则表达式特性。下面列出了ECMAScript正则表达式不支持的特性。</p>
<ul>
<li>匹配字符串开始和结尾的\A和\Z锚</li>
<li>向后查找（lookbehind）</li>
<li>并集和交集类□ 原子组（atomic grouping）</li>
<li>Unicode支持（单个字符除外，如\uFFFF）</li>
<li>命名的捕获组</li>
<li>s（single，单行）和*（free-spacing，无间隔）匹配模式</li>
<li>条件匹配</li>
<li>正则表达式注释</li>
</ul>
<h2 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h2><h3 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h3><p>javascript中的函数没有重载，后定义的同名函数会替代之前定义的函数。因为函数名知识一个指向函数的指针而已。后定义的同名函数，只是重新创建一个函数对象，并修改函数名的指向。</p>
<h3 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h3><p>解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(sum(<span class="number">10</span>, <span class="number">10</span>));</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码完全可以正常运行。因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，JavaScript引擎也能把函数声明提升到顶部。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(sum(<span class="number">10</span>, <span class="number">10</span>));</div><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>以上代码之所以会在运行期间产生错误，原因在于函数位于一个初始化语句中，而不是一个函数声明。换句话说，在执行到函数所在的语句之前，变量sum中不会保存有对函数的引用；而且，由于第一行代码就会导致”unexpected identifier”（意外标识符）错误，实际上也不会执行到下一行。</p>
<blockquote>
<p>除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。</p>
<p>也可以同时使用函数声明和函数表达式，例如var sum = function sum(){}。不过，这种语法在Safari中会导致错误。</p>
</blockquote>
<h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3><p>因为ECMAScript中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeFunction</span>(<span class="params">someFunction, someArgument</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> someFunction(someArgument);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 这个函数接受两个参数。第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。然后，就可以像下面的例子一样传递函数了。</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add10</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> num + <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = callSomeFunction(add10, <span class="number">10</span>);</div><div class="line">alert(result); <span class="comment">// 20</span></div></pre></td></tr></table></figure>
<p>当然，可以从一个函数中返回另一个函数，而且这也是极为有用的一种技术。例如，假设有一个对象数组，我们想要根据某个对象属性对数组进行排序。而传递给数组sort()方法的比较函数要接收两个参数，即要比较的值。可是，我们需要一种方式来指明按照哪个属性来排序。要解决这个问题，可以定义一个函数，它接收一个属性名，然后根据这个属性名来创建一个比较函数，下面就是这个函数的定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFuntion</span>(<span class="params">propertyName</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> value1 = object1[propertyName];</div><div class="line">		<span class="keyword">var</span> value2 = object2[propertyName];</div><div class="line">		<span class="keyword">return</span> value1 &gt; value2;</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 这个函数定义看起来有点复杂，但实际上无非就是在一个函数中嵌套了另一个函数，而且内部函数前面加了一个return操作符。在内部函数接收到propertyName参数后，它会使用方括号表示法来取得给定属性的值。取得了想要的属性值之后，定义比较函数就非常简单了。上面这个函数可以像在下面例子中这样使用。 */</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> data = [&#123;<span class="attr">name</span>: <span class="string">"A"</span>, <span class="attr">age</span>: <span class="number">28</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">"B"</span>, <span class="attr">age</span>: <span class="number">26</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">"C"</span>, <span class="attr">age</span>: <span class="number">29</span>&#125;];</div><div class="line"></div><div class="line">data.sort(createComparisonFunction(<span class="string">"age"</span>));</div><div class="line">alert(data[<span class="number">0</span>].name); <span class="comment">// "C"</span></div></pre></td></tr></table></figure>
<h3 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h3><p>在函数内部，有两个特殊的对象：arguments和this。</p>
<ul>
<li>arguments是一个类数组对象，包含着传入函数中的所有参数。虽然arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。请看下面这个非常经典的阶乘函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span>(num &lt;=<span class="number">1</span> ) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">return</span> fatorial(num<span class="number">-1</span>) * num;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义阶乘函数一般都要用到递归算法；如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名factorial紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用arguments.callee。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span>(num &lt;=<span class="number">1</span> ) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>) * num;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个重写后的factorial()函数的函数体内，没有再引用函数名factorial。这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> trueFactorial = factorial;</div><div class="line"></div><div class="line">factorial = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">alert(trueFactorial(<span class="number">5</span>)); <span class="comment">// 120</span></div><div class="line">alert(factorial(<span class="number">5</span>));  <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<ul>
<li><p>this，其行为与Java和C#中的this大致类似。换句话说，this引用的是函数据以执行的环境对象一一或者也可以说是this值（当在网页的全局作用域中调用函数时，this对象引用的就是window）。</p>
</li>
<li><p>caller, 这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null。</p>
</li>
</ul>
<blockquote>
<p>当函数在严格模式下运行时，访问arguments.callee会导致错误。ECMAScript 5还定义了arguments.caller属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是undefined。定义这个属性是为了分清arguments.caller和函数的caller属性。以上变化都是为了加强这门语言的安全性，这样第三方代码就不能在相同的环境里窥视其他代码了。</p>
<p>严格模式还有一个限制：不能为函数的caller属性赋值，否则会导致错误。</p>
</blockquote>
<h3 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li><p>length<br>length属性表示函数希望接收的命名参数的个数(即定义函数时，显式设置的参数的个数)</p>
</li>
<li><p>prototype<br>对于ECMAScript中的引用类型而言，prototype是保存它们所有实例方法的真正所在。换句话说，诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问罢了。</p>
<blockquote>
<p>在ECMAScript 5中，prototype属性是不可枚举的，因此使用for-in无法发现。</p>
</blockquote>
</li>
</ul>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。</p>
<ul>
<li>apply()<br>apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例，也可以是arguments对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, [num1, num2]);</div><div class="line">	<span class="comment">// return sum.apply(this, arguments);</span></div><div class="line">&#125;</div><div class="line">alert(callSum(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20</span></div></pre></td></tr></table></figure>
<ul>
<li>call()<br>对于call()方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> sum.call(<span class="keyword">this</span>, num1, num2);</div><div class="line">&#125;</div><div class="line">alert(callSum(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20</span></div></pre></td></tr></table></figure>
<p>事实上，传递参数并非apply()和call()真正的用武之地；它们真正强大的地方是能够扩充函数赖以运行的作用域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</div><div class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.color);</div><div class="line">&#125;</div><div class="line"></div><div class="line">sayColor(); <span class="comment">// red</span></div><div class="line"></div><div class="line">sayColor.call(<span class="keyword">this</span>); <span class="comment">// red</span></div><div class="line">sayColor.call(<span class="built_in">window</span>); <span class="comment">// red</span></div><div class="line">sayColor.call(o); <span class="comment">// blue</span></div></pre></td></tr></table></figure>
<ul>
<li>bind()<br>这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</div><div class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.color);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> objectSayColor = sayColor.bind(o);</div><div class="line">objectSayColor(); <span class="comment">// "blue"</span></div></pre></td></tr></table></figure>
<blockquote>
<p>支持bind()方法的浏览器有IE9+、Firefox 4+、Safari 5.1+、Opera 12+和Chrome。</p>
</blockquote>
<ul>
<li>toLocaleString() &amp;&amp; toString() &amp;&amp; valueOf()<br>每个函数继承的toLocaleString()和toString()方法始终都返回函数的代码。返回代码的格式则因浏览器而异一一有的返回的代码与源代码中的函数代码一样，而有的则返回函数代码的内部表示，即由解析器删除了注释并对某些代码作了改动后的代码。由于存在这些差异，我们无法根据这两个方法返回的结果来实现任何重要功能；不过，这些信息在调试代码时倒是很有用。另外一个继承的valueOf()方法同样也只返回函数代码。</li>
</ul>
<h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><p>为了便于操作基本类型值，ECMAScript还提供了3个特殊的引用类型：Boolean、Number和String。这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。</p>
<h3 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h3><p>Boolean类型是与布尔值对应的引用类型。要创建Boolean对象，可以像下面这样调用Boolean构造函数并传入true或false值。</p>
<p><code>var booleanObject = new Boolean(true);</code></p>
<p>Boolean类型的实例重写了valueOf()方法，返回基本类型值重写了toString()方法，返回字符串”true”和”false”。可是，Boolean对象在ECMAScript中的用处不大，因为它经常会造成人们的误解。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> falseObj = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</div><div class="line">falseObj &amp;&amp; <span class="literal">true</span>; <span class="comment">// true</span></div></pre></td></tr></table></figure>
<blockquote>
<p>建议永远不要使用Boolean对象。</p>
</blockquote>
<h3 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h3><p>Number是与数字值对应的引用类型。要创建Number对象，可以在调用Number构造函数时向其中传递相应的数值。下面是一个例子。</p>
<p><code>var numberObj = new Number(10);</code></p>
<p>与Boolean类型一样，Number类型也重写了valueOf()、toLocaleString()和toString()方法。重写后的valueOf()方法返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的数值。可以为toString()方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</div><div class="line">alert(num.toString(<span class="number">2</span>)); <span class="comment">// "1010"</span></div></pre></td></tr></table></figure>
<p>除了继承的方法之外，Number类型还提供了一些用于将数值格式化为字符串的方法。</p>
<ul>
<li>toFixed()<br>按照指定的小数位返回数值的字符串表示</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">10.005</span>;</div><div class="line">alert(num.toFixed(<span class="number">2</span>)); <span class="comment">//"10.01"</span></div></pre></td></tr></table></figure>
<blockquote>
<p>在给toFixed()传入0的情况下，IE8及之前版本不能正确舍入范围在{（-0.94，-0.5]，[0.5，0.94）}之间的值。对于这个范围内的值，IE会返回0，而不是-1或1；其他浏览器都能返回正确的值。IE9修复了这个问题。</p>
</blockquote>
<ul>
<li>toExponential()<br>接收一个参数，而且该参数同样也是指定输出结果中的小数位数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</div><div class="line">alert(num.toExponential(<span class="number">1</span>)); <span class="comment">//"1.0e+1"</span></div></pre></td></tr></table></figure>
<ul>
<li>toPrecision()<br>对于一个数值来说，toPrecision()方法可能会返回固定大小（fixed）格式，也可能返回指数（exponential）格式；具体规则是看哪种格式最合适。</li>
</ul>
<h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>String类型是字符串的对象包装类型，可以像下面这样使用String构造函数来创建。</p>
<p><code>var stringObj = new String(&quot;Hello World&quot;);</code></p>
<p>String对象的方法也可以在所有基本的字符串值中访问到。其中，继承的valueOf()、toLocale-String()和toString()方法，都返回对象所表示的基本字符串值。</p>
<p>String类型的每个实例都有一个length属性，表示字符串中包含多个字符。</p>
<h4 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h4><ul>
<li>charAt()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"Hello World"</span>;</div><div class="line">alert(stringValue.charAt(<span class="number">1</span>)); <span class="comment">// "e"</span></div></pre></td></tr></table></figure>
<ul>
<li>charCodeAt()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"Hello World"</span>;</div><div class="line">alert(stringValue.charCodeAt(<span class="number">1</span>)); <span class="comment">// 101</span></div></pre></td></tr></table></figure>
<blockquote>
<p>ECMAScript5还定义了另一个访问个别字符的方法。在支持浏览器中，可以使用方括号加数字索引来访问字符串中的特定字符<br>使用方括号表示法访问个别字符的语法得到了IE8及Firefox、Safari、Chrome和Opera所有版本的支持。如果是在IE7及更早版本中使用这种语法，会返回undefined值（尽管根本不是特殊的undefined值）。</p>
</blockquote>
<h4 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h4><ul>
<li>concat()<br>用于将一或多个字符串拼接起来，返回拼接得到的新字符串。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello "</span>;</div><div class="line"><span class="keyword">var</span> result = stringValue.concat(<span class="string">"world"</span>);</div><div class="line">alert(result); <span class="comment">// "hello world"</span></div><div class="line">alert(stringValue); <span class="comment">//"hello "</span></div><div class="line"></div><div class="line">result = stringValue.concat(<span class="string">"world"</span>, <span class="string">"!"</span>); <span class="comment">// "hello world!"</span></div></pre></td></tr></table></figure>
<ul>
<li>slice()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello"</span>;</div><div class="line"><span class="keyword">var</span> result = stringValue.slice(<span class="number">3</span>); <span class="comment">// "lo"</span></div><div class="line"><span class="keyword">var</span> result = stringValue.slice(<span class="number">3</span>,<span class="number">4</span>); <span class="comment">// "l"</span></div></pre></td></tr></table></figure>
<ul>
<li>substring()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello "</span>;</div><div class="line"><span class="keyword">var</span> result = stringValue.substring(<span class="number">3</span>,<span class="number">4</span>); <span class="comment">// "l"</span></div></pre></td></tr></table></figure>
<ul>
<li>substr()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello"</span>;</div><div class="line"><span class="keyword">var</span> result = stringValue.substr(<span class="number">3</span>); <span class="comment">// "lo"</span></div><div class="line"><span class="keyword">var</span> result = stringValue.substr(<span class="number">3</span>,<span class="number">1</span>); <span class="comment">// "l"</span></div></pre></td></tr></table></figure>
<p>在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。其中，slice()方法会将传入的负值与字符串的长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0。最后，substring()方法会把所有负值参数都转换为0。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</div><div class="line">stringValue.slice(<span class="number">-3</span>); <span class="comment">// "rld"</span></div><div class="line">stringValue.substring(<span class="number">-3</span>); <span class="comment">// "hello world"</span></div><div class="line">stringValue.substr(<span class="number">-3</span>); <span class="comment">// "rld"</span></div><div class="line">stringValue.slice(<span class="number">3</span>,<span class="number">-4</span>); <span class="comment">// "lo w"</span></div><div class="line">stringValue.substring(<span class="number">3</span>,<span class="number">-4</span>); <span class="comment">// "hel"</span></div><div class="line">stringValue.substr(<span class="number">3</span>,<span class="number">-4</span>); <span class="comment">// ""</span></div></pre></td></tr></table></figure>
<blockquote>
<p>IE的JavaScript实现在处理向substr()方法传递负值的情况时存在问题，它会返回原始的字符串。IE9修复了这个问题。</p>
</blockquote>
<h4 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h4><ul>
<li>indexOf()</li>
<li>lastIndexOf()</li>
</ul>
<p>这两个方法都是从一个字符串中搜索给定的子字符串，然后返子字符串的位置（如果没有找到该子字符串，则返回-1）。这两个方法的区别在于：indexOf()方法从字符串的开头向后搜索子字符串，而lastIndexOf()方法是从字符串的末尾向前搜索子字符串。</p>
<h4 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim()方法"></a>trim()方法</h4><p>ECMAScript 5为所有字符串定义了trim()方法。这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。</p>
<blockquote>
<p>支持这个方法的浏览器有IE9+、Firefox 3.5+、Safari 5+、Opera 10.5+和Chrome。此外，Firefox 3.5+、Safari 5+和Chrome8+还支持非标准的trimLeft()和trimRight()方法，分别用于删除字符串开头和末尾的空格。</p>
</blockquote>
<h4 id="字符串大小转换方法"><a href="#字符串大小转换方法" class="headerlink" title="字符串大小转换方法"></a>字符串大小转换方法</h4><ul>
<li>toLowerCase()</li>
<li>toLocaleLowerCase()</li>
<li>toUpperCase()</li>
<li>toLocaleUpperCase()</li>
</ul>
<p>toLowerCase()和toUpperCase()是两个经典的方法，借鉴自java.lang.String中的同名方法。而toLocaleLowerCase()和toLocaleUpperCase()方法则是针对特定地区的实现。对有些地区来说，针对地区的方法与其通用方法得到的结果相同，但少数语言（如土耳其语）会为Unicode大小写转换应用特殊的规则，这时候就必须使用针对地区的方法来保证实现正确的转换。</p>
<blockquote>
<p>一般来说，在不知道自己的代码将在哪种语言环境中运行的情况下，还是使用针对地区的方法更稳妥一些。</p>
</blockquote>
<h4 id="字符串的模式匹配方法"><a href="#字符串的模式匹配方法" class="headerlink" title="字符串的模式匹配方法"></a>字符串的模式匹配方法</h4><ul>
<li>match()<br>在字符串上调用这个方法，本质上与调用RegExp的exec()方法相同。match()方法只接受一个参数，要么是一个正则表达式，要么是一个RegExp对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"cat bat sat fat"</span></div><div class="line"><span class="keyword">var</span> pattern = <span class="regexp">/.at/</span></div><div class="line"><span class="keyword">var</span> matches = text.match(pattern) <span class="comment">// [ 'cat', index: 0, input: 'cat bat sat fat' ]</span></div></pre></td></tr></table></figure>
<ul>
<li>search()<br>这个方法的唯一参数与match()方法的参数相同：由字符串或RegExp对象指定的一个正则表达式。search()方法返回字符串中第一个匹配项的索引；如果没有找到匹配项，则返回-1。而且，search()方法始终是从字符串开头向后查找模式。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"cat bat sat fat"</span></div><div class="line"><span class="keyword">var</span> pos = text.search(<span class="regexp">/at/</span>) <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<ul>
<li>replace()<br>这个方法接受两个参数：第一个参数可以是一个RegExp对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局（g）标志。</li>
</ul>
<p>如果第二个参数是字符串，那么还可以使用一些特殊的字符序列，将正则表达式操作得到的值插入到结果字符串中。下表列出了ECMAScript提供的这些特殊的字符序列。</p>
<table>
<thead>
<tr>
<th>字符序列</th>
<th>替换文本</th>
</tr>
</thead>
<tbody>
<tr>
<td>$$</td>
<td>$</td>
</tr>
<tr>
<td>$&amp;</td>
<td>匹配整个模式的子字符串。与RegExp.lastMatch的值相同</td>
</tr>
<tr>
<td>$’</td>
<td>匹配的子字符串之前的子字符串。与RegExp.leftContext的值相同</td>
</tr>
<tr>
<td>$、</td>
<td>匹配的子字符串之后的子字符串。与RegExp.rightContext的值相同</td>
</tr>
<tr>
<td>$n</td>
<td>匹配第n捕获组的子字符串，其中n等于0~9。例如，\$1是匹配第一个捕获组的子字符串，\$2是匹配第二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串</td>
</tr>
<tr>
<td>$nn</td>
<td>匹配第nn个捕获组的子字符串，其中nn等于01~99。例如，\$01是匹配第一个捕获组的子字符串，\$02是匹配第二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串</td>
</tr>
</tbody>
</table>
<p>replace()方法的第二个参数也可以是一个函数。在只有一个匹配项（即与模式匹配的字符串）的情况下，会向这个函数传递3个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项……，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始字符串。这个函数应该返回一个字符串，表示应该被替换的匹配项使用函数作为replace()方法的第二个参数可以实现更加精细的替换操作。</p>
<h4 id="localeCompare-方法"><a href="#localeCompare-方法" class="headerlink" title="localeCompare()方法"></a>localeCompare()方法</h4><p>这个方法比较两个字符串，并返回下列值中的一个</p>
<ul>
<li>如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1，具体的值要视实现而定）</li>
<li>如果字符串等于字符串参数，则返回0</li>
<li>如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是1，具体的值同样要视实现而定）</li>
</ul>
<blockquote>
<p>localeCompare()方法比较与众不同的地方，就是实现所支持的地区（国家和语言）决定了这个方法的行为。比如，美国以英语作为ECMAScript实现的标准语言，因此localeCompare()就是区分大小写的，于是大写字母在字母表中排在小写字母前头就成为了一项决定性的比较规则。不过，在其他地区恐怕就不是这种情况了。</p>
</blockquote>
<h4 id="fromCharCode-方法"><a href="#fromCharCode-方法" class="headerlink" title="fromCharCode()方法"></a>fromCharCode()方法</h4><p>这个方法的任务是接收一或多个字符编码，然后将它们转换成一个字符串。从本质上来看，这个方法与实例方法charCodeAt()执行的是相反的操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(<span class="built_in">String</span>.fromCharCode(<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>)); <span class="comment">//"hello"</span></div></pre></td></tr></table></figure>
<h4 id="HTML方法"><a href="#HTML方法" class="headerlink" title="HTML方法"></a>HTML方法</h4><p>早期的Web浏览器提供商觉察到了使用JavaScript动态格式化HTML的需求。于是，这些提供商就扩展了标准，实现了一些专门用于简化常见HTML格式化任务的方法。下表列出了这些HTML方法。不过，需要请读者注意的是，应该尽量不使用这些方法，因为它们创建的标记通常无法表达语义。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">anchor（name） <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span> = <span class="string">"name"</span>&gt;</span>string<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">big() <span class="tag">&lt;<span class="name">big</span>&gt;</span>string<span class="tag">&lt;/<span class="name">big</span>&gt;</span> </div><div class="line">bold() <span class="tag">&lt;<span class="name">b</span>&gt;</span>string<span class="tag">&lt;/<span class="name">b</span>&gt;</span></div><div class="line">fixed() <span class="tag">&lt;<span class="name">tt</span>&gt;</span>string<span class="tag">&lt;/<span class="name">tt</span>&gt;</span></div><div class="line">fontcolor（color） <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"color"</span>&gt;</span>string<span class="tag">&lt;/<span class="name">font</span>&gt;</span> </div><div class="line">fontsize（size） <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">"size"</span>&gt;</span>string<span class="tag">&lt;/<span class="name">font</span>&gt;</span> </div><div class="line">italics() <span class="tag">&lt;<span class="name">i</span>&gt;</span>string<span class="tag">&lt;/<span class="name">i</span>&gt;</span> </div><div class="line">link（url） <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">“url</span>"&gt;</span>string<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </div><div class="line">small() <span class="tag">&lt;<span class="name">small</span>&gt;</span>string<span class="tag">&lt;/<span class="name">small</span>&gt;</span> </div><div class="line">strike() <span class="tag">&lt;<span class="name">strike</span>&gt;</span>string<span class="tag">&lt;/<span class="name">strike</span>&gt;</span> </div><div class="line">sub() <span class="tag">&lt;<span class="name">sub</span>&gt;</span>string<span class="tag">&lt;/<span class="name">sub</span>&gt;</span> </div><div class="line">sup() <span class="tag">&lt;<span class="name">sup</span>&gt;</span>string<span class="tag">&lt;/<span class="name">sup</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h2><p>ECMA-262对内置对象的定义是：“由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。”意思就是说，开发人员不必显式地实例化内置对象，因为它们已经实例化了。前面我们已经介绍了大多数内置对象，例如Object、Array和String。ECMA-262还定义了两个单体内置对象：Global和Math。</p>
<h3 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h3><p>Global（全局）对象可以说是ECMAScript中最特别的一个对象了，因为不管你从什么角度上看，这个对象都是不存在的。ECMAScript中的Global对象在某种意义上是作为一个终极的“兜底儿对象”来定义的。换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是Global对象的属性。本书前面介绍过的那些函数，诸如isNaN()、isFinite()、parseInt()以及parseFloat()，实际上全都是Global对象的方法。除此之外，Global对象还包含其他一些方法。</p>
<h4 id="URI编码方法"><a href="#URI编码方法" class="headerlink" title="URI编码方法"></a>URI编码方法</h4><p>Global对象的encodeURI()和encodeURIComponent()方法可以对URI（ Uniform Resource Identifiers，通用资源标识符）进行编码，以便发送给浏览器。有效的URI中不能包含某些字符，例如空格。而这两个URI编码方法就可以对URI进行编码，它们用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。</p>
<ul>
<li><code>encodeURI()</code><br>主要用于整个URI（例如，<code>http://www.wrox.com/illegal value.html</code>）</li>
<li><code>encodeURIComponent()</code><br>主要用于对URI中的某一段（例如前面URI中的illegal value.html）进行编码。</li>
</ul>
<p>它们的主要区别在于，encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。</p>
<ul>
<li><code>decodeURI()</code><br>与encodeURI()对应</li>
<li><code>decodeURIComponent()</code><br>与encodeURIComponent()对应</li>
</ul>
<h4 id="eval-方法"><a href="#eval-方法" class="headerlink" title="eval()方法"></a>eval()方法</h4><p>eval()方法就像是一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript（或JavaScript）字符串。看下面的例子：</p>
<p><code>eval(&quot;alert(&#39;hi&#39;)&quot;)</code></p>
<p>这行代码的作用等价于下面这行代码：</p>
<p><code>alert(&quot;hi&quot;)；</code></p>
<p>当解析器发现代码中调用eval()方法时，它会将传入的参数当作实际的ECMAScript语句来解析，然后把执行结果插入到原位置。通过eval()执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链。这意味着通过eval()执行的代码可以引用在包含环境中定义的变量。</p>
<blockquote>
<p>在eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；它们只在eval()执行的时候创建。</p>
<p>严格模式下，在外部访问不到eval()中创建的任何变量或函数</p>
</blockquote>
<h4 id="Global对象的属性"><a href="#Global对象的属性" class="headerlink" title="Global对象的属性"></a>Global对象的属性</h4><table>
<thead>
<tr>
<th>属性</th>
</tr>
</thead>
<tbody>
<tr>
<td>undefined</td>
</tr>
<tr>
<td>NaN</td>
</tr>
<tr>
<td>Infinity</td>
</tr>
<tr>
<td>Object</td>
</tr>
<tr>
<td>Array</td>
</tr>
<tr>
<td>Function</td>
</tr>
<tr>
<td>Boolean</td>
</tr>
<tr>
<td>String</td>
</tr>
<tr>
<td>Numner</td>
</tr>
<tr>
<td>Date</td>
</tr>
<tr>
<td>RegExp</td>
</tr>
<tr>
<td>Error</td>
</tr>
<tr>
<td>EvalError</td>
</tr>
<tr>
<td>RangeError</td>
</tr>
<tr>
<td>ReferenceError</td>
</tr>
<tr>
<td>SyntaxError</td>
</tr>
<tr>
<td>TypeError</td>
</tr>
<tr>
<td>URIError</td>
</tr>
</tbody>
</table>
<h4 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h4><p>ECMAScript虽然没有指出如何直接访问Global对象，但Web浏览器都是将这个全局对象作为window对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了window对象的属性。</p>
<h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><ul>
<li>Math.E</li>
<li>Math.LN10</li>
<li>Math.LN2</li>
<li>Math.LOG2E</li>
<li>Math.PI</li>
<li>Math.SQRT1_2</li>
<li>Math.SQRT2</li>
</ul>
<h4 id="main-和max-方法"><a href="#main-和max-方法" class="headerlink" title="main()和max()方法"></a>main()和max()方法</h4><p>min()和max()方法用于确定一组数值中的最小值和最大值。这两个方法都可以接收任意多个数值参数。</p>
<blockquote>
<p>要找到数组中的最大或最小值，可以像下面这样使用apply()方法。</p>
<p>var values = [1, 2, 3, 4];<br>var max = Math.max.apply(Math, values);</p>
</blockquote>
<h4 id="舍入方法"><a href="#舍入方法" class="headerlink" title="舍入方法"></a>舍入方法</h4><ul>
<li><code>Math.ceil()</code><br>Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数</li>
<li><code>Math.floor()</code><br>Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数</li>
<li><code>Math.round()</code><br>Math.round()执行标准舍入，即它总是将数值四舍五人为最接近的整数（这也是我们在数学课上学到的舍入规则</li>
</ul>
<h4 id="random-方法"><a href="#random-方法" class="headerlink" title="random()方法"></a>random()方法</h4><p>Math.random()方法返回介于0和1之间一个随机数，不包括0和1。</p>
<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><table>
<thead>
<tr>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>abs(num)</td>
</tr>
<tr>
<td>exp(num)</td>
</tr>
<tr>
<td>log(num)</td>
</tr>
<tr>
<td>pow(num,power)</td>
</tr>
<tr>
<td>sqrt(num)</td>
</tr>
<tr>
<td>acos(x)</td>
</tr>
<tr>
<td>asin(x)</td>
</tr>
<tr>
<td>atan(x)</td>
</tr>
<tr>
<td>atan2(y,x)</td>
</tr>
<tr>
<td>cos(x)</td>
</tr>
<tr>
<td>sin(x)</td>
</tr>
<tr>
<td>tan(x)</td>
</tr>
</tbody>
</table>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>引用类型与传统面向对象程序设计中的类相似，但实现不同；</li>
<li>Object是一个基础类型，其他所有类型都从Object继承了基本的行为；</li>
<li>Array类型是一组值的有序列表，同时还提供了操作和转换这些值的功能；</li>
<li>Date类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能；</li>
<li>RegExp类型是ECMAScript支持正则表达式的一个接口，提供了最基本的和一些高级的正则表达式功能。<br>函数实际上是Function类型的实例，因此函数也是对象；而这一点正是JavaScript最有特色的地方。由于函数是对象，所以函数也拥有方法，可以用来增强其行为。</li>
</ul>
<p>因为有了基本包装类型，所以JavaScript中的基本类型值可以被当作对象来访问。三种基本包装类型分别是：Boolean、Number和String。以下是它们共同的特征：</p>
<ul>
<li>每个包装类型都映射到同名的基本类型；</li>
<li>在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据操作；</li>
<li>操作基本类型值的语句一经执行完毕，就会立即销毁新创建的包装对象。</li>
</ul>
<p>在所有代码执行之前，作用域中就已经存在两个内置对象：Global和Math。在大多数ECMAScript实现中都不能直接访问Global对象；不过，Web浏览器实现了承担该角色的window对象。全局变量和函数都是Global对象的属性。Math对象提供了很多属性和方法，用于辅助完成复杂的数学计算任务。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/05/JavaScript的变量、作用域和内存问题/" itemprop="url">
                  JavaScript的变量、作用域和内存问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-05T10:28:55+08:00" content="2016-08-05">
              2016-08-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/javascript笔记/" itemprop="url" rel="index">
                    <span itemprop="name">javascript笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h2><ul>
<li>引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的。</li>
<li>string类型不是对象</li>
</ul>
<h3 id="动态的属性"><a href="#动态的属性" class="headerlink" title="动态的属性"></a>动态的属性</h3><ul>
<li>对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。</li>
<li>不能给基本类型的值添加属性，尽管这样做不会导致任何错误。</li>
</ul>
<h3 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h3><ul>
<li>如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> num2 = num1; <span class="comment">// 5</span></div><div class="line"></div><div class="line"><span class="comment">// 修改num1的值，不会影响num2的值</span></div><div class="line">num1 = <span class="number">6</span>;</div><div class="line">alert(num2);     <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<ul>
<li>当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"><span class="keyword">var</span> obj2 = obj1;</div><div class="line">obj1.name = <span class="string">"Nicholas"</span>;</div><div class="line">alert(obj2.name); <span class="comment">// "Nicholas"</span></div></pre></td></tr></table></figure>
<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><ul>
<li>ECMAScript中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add10</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">    num += <span class="number">10</span>;</div><div class="line">    <span class="keyword">return</span> num;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> number = <span class="number">10</span>;</div><div class="line"><span class="keyword">var</span> number2 = add10(number); <span class="comment">// 此时number值为10；number2值为20.</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    obj.name = <span class="string">"Nicholas"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">setName(person);</div><div class="line">alert(person.name) <span class="comment">// "Nicholas"</span></div></pre></td></tr></table></figure>
<ul>
<li>有很多开发人员错误地认为：在局部作用域中修改的对象会在全局作用域中反映出来，就说明参数是按引用传递的。为了证明对象是按值传递的，我们再看一看下面这个经过修改的例子：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    obj.name = <span class="string">"nicholas"</span>;</div><div class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    obj.name = <span class="string">"Greg"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">setName(person);</div><div class="line">alert(person.name); <span class="comment">// "Nicholas"</span></div></pre></td></tr></table></figure>
<p>这个例子与前一个例子的唯一区别，就是在setName()函数中添加了两行代码：一行代码为obj重新定义了一个对象，另一行代码为该对象定义了一个带有不同值的name属性。在把person传递给setName()后，其name属性被设置为”Nicholas”。然后，又将一个新对象赋给变量obj，同时将其name属性设置为”Greg”。如果person是按引用传递的，那么person就会自动被修改为指向其name属性值为”Greg”的新对象。但是，当接下来再访问person.name时，显示的值仍然是”Nicholas”。这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写obj时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。</p>
<blockquote>
<p>关于什么是值传递，什么是引用传递</p>
<p>值传递：<br>形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参-&gt;形参），参数的值只能传入，不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。</p>
<p>引用传递：<br>形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。</p>
</blockquote>
<h3 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h3><ul>
<li>检测一个变量是不是基本数据类型，使用typeof</li>
<li><p>检测一个值是什么类型的对象，使用instanceof</p>
<ul>
<li><p>如果变量是给定引用类型的实例，那么instanceof操作符就会返回true。请看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>根据规定，所有引用类型的值都是Object的实例。因此，在检测一个引用类型值和Object构造函数时，instanceof操作符始终会返回true。当然，如果使用instanceof操作符检测基本类型的值，则该操作符始终会返回false，因为基本类型不是对象。</p>
</li>
</ul>
</li>
</ul>
<h2 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h2><p><strong>执行环境</strong>（execution context，为简单起见，有时也称为“环境”）是JavaScript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。</p>
<p><strong>全局执行环境</strong>是最外围的一个执行环境。根据ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。在Web浏览器中，全局执行环境被认为是window对象（第7章将详细讨论），因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁）。</p>
<p>每个函数都有自己的<strong>执行环境</strong>。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript程序中的执行流正是由这个方便的机制控制着。</p>
<p>当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p>
<p><strong>标识符解析</strong>是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。</p>
<h3 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h3><p>虽然执行环境的类型总共只有两种——全局和局部（函数），但还是有其他办法来延长作用域链。这么说是因为有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。<br>在两种情况下会发生这种现象。具体来说，就是当执行流进入下列任何一个语句时，作用域链就会得到加长：</p>
<ol>
<li>try-catch语句的catch块；</li>
<li>with语句。</li>
</ol>
<p>这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会将指定的对象添加到作用域链中。对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。</p>
<h3 id="没有块级作用域"><a href="#没有块级作用域" class="headerlink" title="没有块级作用域"></a>没有块级作用域</h3><ul>
<li>对于有块级作用域的语言来说，for语句初始化变量的表达式所定义的变量，只会存在于循环的环境之中。而对于JavaScript来说，由for语句创建的变量i即使在for循环执行结束后，也依旧会存在于循环外部的执行环境中。</li>
</ul>
<h4 id="1-变量声明"><a href="#1-变量声明" class="headerlink" title="1. 变量声明"></a>1. 变量声明</h4><ul>
<li>使用var声明的变量会自动被添加到最接近的环境中。</li>
<li>在函数内部，最接近的环境就是函数的局部环境；在with语句中，最接近的环境是函数环境。</li>
<li>如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境。<blockquote>
<p>在编写JavaScript代码的过程中，不声明而直接初始化变量是一个常见的错误做法，因为这样可能会导致意外。我们建议在初始化变量之前，一定要先声明，这样就可以避免类似问题。在严格模式下，初始化未经声明的变量会导致错误。</p>
</blockquote>
</li>
</ul>
<h4 id="2-查询标识符"><a href="#2-查询标识符" class="headerlink" title="2. 查询标识符"></a>2. 查询标识符</h4><p>当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。</p>
<h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。</p>
<p>这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性地执行这一操作。</p>
<p>下面我们来分析一下函数中局部变量的正常生命周期。局部变量只在函数执行的过程中存在。而在这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便存储它们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。在这种情况下，很容易判断变量是否还有存在的必要；但并非所有情况下都这么容易就能得出结论。垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略。</p>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>JavaScript中最常用的垃圾收集方式是标记清除（mark-and-sweep）。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。</p>
<p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p>
<blockquote>
<p>到2008年为止，IE、Firefox、Opera、Chrome和Safari的JavaScript实现使用的都是标记清除式的垃圾收集策略（或类似的策略），只不过垃圾收集的时间间隔互有不同。</p>
</blockquote>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>另一种不太常见的垃圾收集策略叫做引用计数（reference counting）。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。</p>
<blockquote>
<p>引用计数有一个十分头痛个问题即循环引用。因此很少被使用。</p>
</blockquote>
<h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。说到垃圾收集器多长时间运行一次，不禁让人联想到IE因此而声名狼藉的性能问题。IE的垃圾收集器是根据内存分配量运行的，具体一点说就是256个变量、4096个对象（或数组）字面量和数组元素（slot）或者64KB的字符串。达到上述任何一个临界值，垃圾收集器就会运行。这种实现方式的问题在于，如果一个脚本中包含那么多变量，那么该脚本很可能会在其生命周期中一直保有那么多的变量。而这样一来，垃圾收集器就不得不频繁地运行。结果，由此引发的严重性能问题促使IE7重写了其垃圾收集例程。</p>
<p>随着IE7的发布，其JavaScript引擎的垃圾收集例程改变了工作方式：触发垃圾收集的变量分配、字面量和（或）数组元素的临界值被调整为动态修正。IE7中的各项临界值在初始时与IE6相等。如果垃圾收集例程回收的内存分配量低于15%，则变量、字面量和（或）数组元素的临界值就会加倍。如果例程回收了85%的内存分配量，则将各种临界值重置回默认值。这一看似简单的调整，极大地提升了IE在运行包含大量JavaScript的页面时的性能。</p>
<h3 id="管理内存"><a href="#管理内存" class="headerlink" title="管理内存"></a>管理内存</h3><p>使用具备垃圾收集机制的语言编写程序，开发人员一般不必操心内存管理的问题。但是，JavaScript在进行内存管理及垃圾收集时面临的问题还是有点与众不同。其中最主要的一个问题，就是分配给Web浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行JavaScript的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。</p>
<p>因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为null来释放其引用——这个做法叫做解除引用（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>JavaScript变量可以用来保存两种类型的值：基本类型值和引用类型值。基本类型的值源自以下5种基本数据类型：Undefined、Null、Boolean、Number和String。基本类型值和引用类型值具有以下特点：</p>
<ul>
<li>基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；</li>
<li>从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；</li>
<li>引用类型的值是对象，保存在堆内存中；</li>
<li>包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；</li>
<li>从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象；</li>
<li>确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符。</li>
</ul>
<p>所有变量（包括基本类型和引用类型）都存在于一个执行环境（也称为作用域）当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几点总结：</p>
<ul>
<li>执行环境有全局执行环境（也称为全局环境）和函数执行环境之分；</li>
<li>每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；</li>
<li>函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全局环境；</li>
<li>全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；</li>
<li>变量的执行环境有助于确定应该何时释放内存。</li>
</ul>
<p>JavaScript是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/01/JavaScript基本概念/" itemprop="url">
                  JavaScript基本概念
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-01T10:28:55+08:00" content="2016-08-01">
              2016-08-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/javascript笔记/" itemprop="url" rel="index">
                    <span itemprop="name">javascript笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>ECMAScript的语法大量借鉴了C及其他类C语言（如Java和Perl）的语法。</p>
<h3 id="区分大小写"><a href="#区分大小写" class="headerlink" title="区分大小写"></a>区分大小写</h3><p>要理解的第一个概念就是ECMAScriptj中的一切（变量、函数名和操作符）都区分大小写。这也就意味着，变量名test和变量名Test分别表示两个不同的变量，而函数名不能使用typeof，因为它是一个关键字（3.2节介绍关键字），但typeOf则完全可以是一个有效的函数名。</p>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。标识符可以是按照下列格式规则组合起来的一或多个字符：</p>
<ol>
<li>第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；</li>
<li>其他字符可以是字母、下划线、美元符号或数字。</li>
</ol>
<p>标识符中的字母也可以包含扩展的ASCII或Unicode字母字符（如A和Æ），但我们不推荐这样做。</p>
<p>按照惯例，ECMAScript标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个有意义的单词的首字母大写，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">firstSecond</div><div class="line">myCar</div><div class="line">doSomethingImportant</div></pre></td></tr></table></figure></p>
<p>虽然没有谁强制要求必须采用这种格式，但为了与ECMAScript内置的函数和对象命名格式保持一致，可以将其当作一种最佳实践。</p>
<p> 不能把关键字、保留字、true、false和null用作标识符。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>ECMAScript使用C风格的注释，包括单行注释和块级注释。单行注释以两个斜杠开头，如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//单行注释</span></div></pre></td></tr></table></figure></p>
<p>块级注释以一个斜杠和一个星号（/<em>）开头，以一个星号和一个斜杠（</em>/）结尾，如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> *这是一个块级注释</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<p>虽然上面注释中的第二和第三行都以一个星号开头，但这不是必需的。之所以添加那两个星号，纯粹是为了提高注释的可读性（这种格式在企业级应用程序中极其常见）。</p>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>ECMAScript 5引入了严格模式（strict mode）的概念。严格模式是为JavaScript定义了一种不同的解析与执行模型。在严格模式下，ECMAScript 3中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div></pre></td></tr></table></figure></p>
<p>这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示（pragma），用于告诉支持的JavaScript引擎切换到严格模式。这是为不破坏ECMAScript 3语法而特意选定的语法。</p>
<p>在函数内部的上方包含这条编译指示，也可以指定函数在严格模式下执行：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="string">"use strict;"</span></div><div class="line">	<span class="comment">//函数体</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>严格模式下，JavaScript的执行结果会有很大不同，因此本书将会随时指出严格模式下的区别。支持严格模式的浏览器包括IE10+、Firefox 4+、Safari 5.1+、Opera 12+和Chrome。</p>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>ECMAScript中的语句以一个分号结尾；如果省略分号，则由解析器确定语句的结尾，如下例所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = a + b <span class="comment">//正确，但不推荐</span></div><div class="line"><span class="keyword">var</span> diff = a-b; <span class="comment">//正确，k推荐</span></div></pre></td></tr></table></figure></p>
<p>虽然语句结尾的分号不是必需的，但我们建议任何时候都不要省略它。因为加上这个分号可以避免很多错误（例如不完整的输入），开发人员也可以放心地通过删除多余的空格来压缩ECMAScript代码（代码行结尾处没有分号会导致压缩错误）。另外，加上分号也会在某些情况下增进代码的性能，因为这样解析器就不必再花时间推测应该在哪里插入分号了。</p>
<p>可以使用C风格的语法把多条语句组合到一个代码块中，即代码块以左花括号（{）开头，以右花括号（}）结尾：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (test) &#123;</div><div class="line">    test =<span class="literal">false</span>;</div><div class="line">    alert(test);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然条件控制语句（如if语句）只在执行多条语句的情况下才要求使用代码块，但最佳实践是始终在控制语句中使用代码块——即使代码块中只有一条语句，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (test) </div><div class="line">    alert(test); <span class="comment">//有效，但不推荐</span></div><div class="line"><span class="keyword">if</span> (test) &#123;</div><div class="line">    alert(test); <span class="comment">//有效，推荐</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在控制语句中使用代码块可以让编码意图更加清晰，而且也能降低修改代码时出错的几率。</p>
<h3 id="关键字和保留字"><a href="#关键字和保留字" class="headerlink" title="关键字和保留字"></a>关键字和保留字</h3><p>ECMA-262描述了一组具有特定用途的关键字，这些关键字可用于表示控制语句的开始或结束，或者用于执行特定操作等。按照规则，关键字也是语言保留的，不能用作标识符。以下就是ECMAScript的全部关键字（带*号上标的是第5版新增的关键字）：</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>关键字</th>
<th>关键字</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>break</td>
<td>do</td>
<td>instanceof</td>
<td>typeof</td>
</tr>
<tr>
<td>case</td>
<td>else</td>
<td>new</td>
<td>var</td>
</tr>
<tr>
<td>catch</td>
<td>finally</td>
<td>return</td>
<td>void</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>switch</td>
<td>while</td>
</tr>
<tr>
<td>debugger*</td>
<td>function</td>
<td>this</td>
<td>with</td>
</tr>
<tr>
<td>default</td>
<td>if</td>
<td>throw</td>
<td></td>
</tr>
<tr>
<td>delete</td>
<td>in</td>
<td>try</td>
</tr>
</tbody>
</table>
<p>ECMA-262还描述了另外一组不能用作标识符的保留字。尽管保留字在这门语言中还没有任何特定的用途，但它们有可能在将来被用作关键字。以下是ECMA-262第3版定义的全部保留字：</p>
<table>
<thead>
<tr>
<th>保留字</th>
<th>保留字</th>
<th>保留字</th>
<th>保留字</th>
</tr>
</thead>
<tbody>
<tr>
<td>abstract</td>
<td>enum</td>
<td>int</td>
<td>short</td>
</tr>
<tr>
<td>boolean</td>
<td>export</td>
<td>interface</td>
<td>static</td>
</tr>
<tr>
<td>byte</td>
<td>extends</td>
<td>long</td>
<td>super</td>
</tr>
<tr>
<td>char</td>
<td>final</td>
<td>native</td>
<td>synchronized</td>
</tr>
<tr>
<td>class</td>
<td>float</td>
<td>package</td>
<td>throws</td>
</tr>
<tr>
<td>const</td>
<td>goto</td>
<td>private</td>
<td>transient</td>
</tr>
<tr>
<td>debugger</td>
<td>implements</td>
<td>protected</td>
<td>volatile</td>
</tr>
<tr>
<td>double</td>
<td>important</td>
<td>public</td>
<td>volatile</td>
</tr>
</tbody>
</table>
<p>第5版把在非严格模式下运行时的保留字缩减为下列这些：</p>
<table>
<thead>
<tr>
<th>保留字</th>
<th>保留字</th>
<th>保留字</th>
<th>保留字</th>
</tr>
</thead>
<tbody>
<tr>
<td>calss</td>
<td>enum</td>
<td>extends</td>
<td>super</td>
</tr>
<tr>
<td>const</td>
<td>export</td>
<td>import</td>
</tr>
</tbody>
</table>
<p>在严格模式下，第5版还对以下保留字施加了限制：</p>
<table>
<thead>
<tr>
<th>保留字</th>
<th>保留字</th>
<th>保留字</th>
</tr>
</thead>
<tbody>
<tr>
<td>implements</td>
<td>package</td>
<td>public</td>
</tr>
<tr>
<td>interface</td>
<td>private</td>
<td>static</td>
</tr>
<tr>
<td>let</td>
<td>protected</td>
<td>yield</td>
</tr>
</tbody>
</table>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>ECMAScript的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值的占位符而已。定义变量时要使用var操作符（注意var是一个关键字），后跟变量名（即一个标识符），如下所示：</p>
<pre><code>var message;
</code></pre><p>这行代码定义了一个名为message的变量，该变量可以用来保存任何值（像这样未经过初始化的变量，会保存一个特殊的值——undefined，相关内容将在3.4节讨论）。ECMAScript也支持直接初始化变量，因此在定义变量的同时就可以设置变量的值，如下所示：</p>
<pre><code>var message =&quot;hi&quot;；
</code></pre><p>在此，变量message中保存了一个字符串值”hi”。像这样初始化变量并不会把它标记为字符串类型；初始化的过程就是给变量赋一个值那么简单。因此，可以在修改变量值的同时修改值的类型，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">"hi"</span>;</div><div class="line">message = <span class="number">100</span>;      <span class="comment">//有效，不推荐</span></div></pre></td></tr></table></figure>
<p>在这个例子中，变量message一开始保存了一个字符串值”hi”，然后该值又被一个数字值100取代。虽然我们不建议修改变量所保存值的类型，但这种操作在ECMAScript中完全有效。</p>
<p>有一点必须注意，即使用var操作符定义的变量将成为定义该变量的作用域中的局部变量。也就是说，如果在函数中使用var定义一个变量，那么这个变量在函数退出后就会被销毁，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> message = <span class="string">"hi"</span>; <span class="comment">//局部变量</span></div><div class="line">&#125;</div><div class="line">test();</div><div class="line">alert(message); <span class="comment">//错误！</span></div></pre></td></tr></table></figure>
<p>这里，变量message是在函数中使用var定义的。当函数被调用时，就会创建该变量并为其赋值。而在此之后，这个变量又会立即被销毁，因此例子中的下一行代码就会导致错误。不过，可以像下面这样省略var操作符，从而创建一个全局变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    message = <span class="string">"hi"</span>; <span class="comment">//全局变量</span></div><div class="line">&#125;</div><div class="line">test();</div><div class="line">alert(message); <span class="comment">// "hi"</span></div></pre></td></tr></table></figure>
<p>这个例子省略了var操作符，因而message就成了全局变量。这样，只要调用过一次test()函数，这个变量就有了定义，就可以在函数外部的任何地方被访问到。</p>
<p>虽然省略var操作符可以定义全局变量，但这也不是我们推荐的做法。因为在局部作用域中定义的全局变量很难维护，而且如果有意地忽略了var操作符，也会由于相应变量不会马上就有定义而导致不必要的混乱。给未经声明的变量赋值在严格模式下会导致抛出ReferenceError错误。<br>可以使用一条语句定义多个变量，只要像下面这样把每个变量（初始化或不初始化均可）用逗号分隔开即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">"hi"</span>,</div><div class="line">    found = <span class="literal">false</span>,</div><div class="line">    age = <span class="number">29</span>;</div></pre></td></tr></table></figure>
<p>这个例子定义并初始化了3个变量。同样由于ECMAScript是松散类型的，因而使用不同类型初始化变量的操作可以放在一条语句中来完成。虽然代码里的换行和变量缩进不是必需的，但这样做可以提高可读性。</p>
<p>在严格模式下，不能定义名为eval或arguments的变量，否则会导致语法错误。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>ECMAScript中有5种简单数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number和String。还有1种复杂数据类型——Object，Object本质上是由一组无序的名值对组成的。ECMAScript不支持任何创建自定义类型的机制，而所有值最终都将是上述6种数据类型之一。乍一看，好像只有6种数据类型不足以表示所有数据；但是，由于ECMAScript数据类型具有动态性，因此的确没有再定义其他数据类型的必要了。</p>
<h3 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h3><p>鉴于ECMAScript是松散类型的，因此需要有一种手段来检测给定变量的数据类型——typeof就是负责提供这方面信息的操作符。对一个值使用typeof操作符可能返回下列某个字符串：</p>
<ol>
<li>“undefined”——如果这个值未定义；</li>
<li>“boolean”——如果这个值是布尔值；</li>
<li>“string”——如果这个值是字符串；</li>
<li>“number”——如果这个值是数值；</li>
<li>“object”——如果这个值是对象或null；</li>
<li>“function”——如果这个值是函数。</li>
</ol>
<p>有些时候，typeof操作符会返回一些令人迷惑但技术上却正确的值。比如，调用typeof null会返回”object”，因为特殊值null被认为是一个空的对象引用。Safari 5及之前版本、Chrome 7及之前版本在对正则表达式调用typeof操作符时会返回“function”，而其他浏览器在这种情况下会返回”object”。</p>
<p>从技术角度讲，函数在ECMAScript中是对象，不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过typeof操作符来区分函数和其他对象是有必要的。</p>
<h3 id="Undefined类型"><a href="#Undefined类型" class="headerlink" title="Undefined类型"></a>Undefined类型</h3><p>Undefined类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message;</div><div class="line">alert(message == <span class="literal">undefined</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>一般而言，不存在需要显式地把一个变量设置为undefined值的情况。字面值undefined的主要目的是用于比较，而ECMA-262第3版之前的版本中并没有规定这个值。第3版引入这个值是为了正式区分空对象指针与未经初始化的变量。<br>不过，包含undefined值的变量与尚未定义的变量还是不一样的。看看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message;</div><div class="line">alert(message);        <span class="comment">// "undefined"</span></div><div class="line">alert(age);            <span class="comment">// error</span></div><div class="line">alert(<span class="keyword">typeof</span> message); <span class="comment">// "undefined"</span></div><div class="line">alert(<span class="keyword">typeof</span> age);     <span class="comment">// "undefined"</span></div></pre></td></tr></table></figure>
<p>结果表明，对未初始化和未声明的变量执行typeof操作符都返回了undefined值；这个结果有其逻辑上的合理性。因为虽然这两种变量从技术角度看有本质区别，但实际上无论对哪种变量也不可能执行真正的操作。</p>
<blockquote>
<p>即便未初始化的变量会自动被赋予undefined值，但显式地初始化变量依然是明智的选择。如果能够做到这一点，那么当typeof操作符返回”undefined”值时，我们就知道被检测的变量还没有被声明，而不是尚未初始化。</p>
</blockquote>
<h3 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h3><p>Null类型是第二个只有一个值的数据类型，这个特殊的值是null。从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null值时会返回”object”的原因。</p>
<p>如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。这样一来，只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的引用了。</p>
<p>实际上，undefined值是派生自null值的，因此ECMA-262规定对它们的相等性测试要返回true。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(<span class="literal">null</span> == <span class="literal">undefined</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>尽管null和undefined有这样的关系，但它们的用途完全不同。如前所述，无论在什么情况下都没有必要把一个变量的值显式地设置为undefined，可是同样的规则对null却不适用。换句话说，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。这样做不仅可以体现null作为空对象指针的惯例，而且也有助于进一步区分null和undefined。</p>
<h3 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h3><p>Boolean类型是ECMAScript中使用得最多的一种类型，该类型只有两个字面值：true和false。这两个值与数字值不是一回事，因此true不一定等于1，而false也不一定等于0。</p>
<p>需要注意的是，Boolean类型的字面值true和false是区分大小写的。也就是说，True和False（以及其他的混合大小写形式）都不是Boolean值，只是标识符。</p>
<p>虽然Boolean类型的字面值只有两个，但ECMAScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用转型函数Boolean()。</p>
<p>可以对任何数据类型的值调用Boolean()函数，而且总会返回一个Boolean值。至于返回的这个值是true还是false，取决于要转换值的数据类型及其实际值。下表给出了各种数据类型及其对应的转换规则。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>转换成true的值</th>
<th>转换成false的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>任何非空字符串</td>
<td>‘’和””</td>
</tr>
<tr>
<td>Number</td>
<td>任何非零数字值（包括无穷大）</td>
<td>0和NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任何对象</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td>n/a</td>
<td>undefined</td>
</tr>
</tbody>
</table>
<h3 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h3><p>Number类型应该是ECMAScript中最令人关注的数据类型了，这种类型使用IEEE754格式来表示整数和浮点数值（浮点数值在某些语言中也被称为双精度数值）。为支持各种数值类型，ECMA-262定义了不同的数值字面量格式。</p>
<p>最基本的数值字面量格式是十进制整数，十进制整数可以像下面这样直接在代码中输入：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> intNum = <span class="number">55</span>; <span class="comment">// 整数</span></div></pre></td></tr></table></figure>
<p>除了以十进制表示外，整数还可以通过八进制（以8为基数）或十六进制（以16为基数）的字面值来表示。其中，八进制字面值的第一位必须是零（0），然后是八进制数字序列（0~7）。如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析。请看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> octalNum1 = <span class="number">070</span>; <span class="comment">//八进制的56</span></div><div class="line"><span class="keyword">var</span> octalNum2 = <span class="number">079</span>; <span class="comment">//无效的八进制数值——解析为79</span></div></pre></td></tr></table></figure>
<p>八进制字面量在严格模式下是无效的，会导致支持的JavaScript引擎抛出错误。</p>
<p>十六进制字面值的前两位必须是0x，后跟任何十六进制数字（0~9及A~F）。其中，字母A~F可以大写，也可以小写。如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> hexNum1 = <span class="number">0xA</span>;  <span class="comment">//十六进制的10</span></div><div class="line"><span class="keyword">var</span> hexNum2 = <span class="number">0x1f</span>; <span class="comment">//十六进制的31</span></div></pre></td></tr></table></figure>
<p>在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。</p>
<h4 id="浮点数值"><a href="#浮点数值" class="headerlink" title="浮点数值"></a>浮点数值</h4><p>所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。虽然小数点前面可以没有整数，但我们不推荐这种写法。</p>
<p>由于保存浮点数值需要的内存空间是保存整数值的两倍，因此ECMAScript会不失时机地将浮点数值转换为整数值。显然，如果小数点后面没有跟任何数字，那么这个数值就可以作为整数值来保存。同样地，如果浮点数值本身表示的就是一个整数（如1.0），那么该值也会被转换为整数，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> floatNum1 = <span class="number">1.</span>;   <span class="comment">//小数点后没有数字——解析为1</span></div><div class="line"><span class="keyword">var</span> floatNum2 = <span class="number">10.0</span>; <span class="comment">//整数——解析为10</span></div></pre></td></tr></table></figure>
<p>对于那些极大或极小的数值，可以用e表示法（即科学计数法）表示的浮点数值表示。</p>
<p>在默认情况下，ECMASctipt会将那些小数点后面带有6个零以上的浮点数值转换为以e表示法表示的数值（例如，0.0000003会被转换成3e-7）。</p>
<p>浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1加0.2的结果不是0.3，而是0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。</p>
<blockquote>
<p>永远不要测试某个特定的浮点数值。</p>
</blockquote>
<h4 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h4><p>由于内存的限制，ECMAScript并不能保存世界上所有的数值。ECMAScript能够表示的最小数值保存在Number.MIN_VALUE中——在大多数浏览器中，这个值是5e-324；能够表示的最大数值保存在Number.MAX_VALUE中——在大多数浏览器中，这个值是1.7976931348623157e+308。如果某次计算的结果得到了一个超出JavaScript数值范围的值，那么这个数值将被自动转换成特殊的Infinity值。具体来说，如果这个数值是负数，则会被转换成-Infinity（负无穷），如果这个数值是正数，则会被转换成Infinity（正无穷）。</p>
<p>如上所述，如果某次计算返回了正或负的Infinity值，那么该值将无法继续参与下一次的计算，因为Infinity不是能够参与计算的数值。要想确定一个数值是不是有穷的（换句话说，是不是位于最小和最大的数值之间），可以使用isFinite()函数。这个函数在参数位于最小与最大数值之间时会返回true。</p>
<p>尽管在计算中很少出现某些值超出表示范围的情况，但在执行极小或极大数值的计算时，检测监控这些值是可能的，也是必需的。<br>访问Number.NEGATIVE_INFINITY和Number.POSITIVE_INFINITY也可以得到负和正Infinity的值。可以想见，这两个属性中分别保存着-Infinity和Infinity。</p>
<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，在其他编程语言中，任何数值除以0都会导致错误，从而停止代码执行。但在ECMAScript中，任何数值除以0会返回NaN，因此不会影响其他代码的执行。</p>
<p>NaN本身有两个非同寻常的特点。首先，任何涉及NaN的操作（例如NaN/10）都会返回NaN，这个特点在多步计算中有可能导致问题。其次，NaN与任何值都不相等，包括NaN本身。</p>
<p>针对NaN的这两个特点，ECMAScript定义了isNaN()函数。这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”。isNaN()在接收到一个值之后，会尝试将这个值转换为数值。某些不是数值的值会直接转换为数值，例如字符串”10”或Boolean值。而任何不能被转换为数值的值都会导致这个函数返回true。</p>
<blockquote>
<p>尽管有点儿不可思议，但isNaN()确实也适用于对象。在基于对象调用isNaN()函数时，会首先调用对象的valueOf()方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个返回值再调用toString()方法，再测试返回值。而这个过程也是ECMAScript中内置函数和操作符的一般执行流程。</p>
</blockquote>
<h4 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h4><p>有3个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat()。第一个函数，即转型函数Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。这3个函数对于同样的输入会有返回不同的结果。</p>
<p>Number()函数转换规则如下:</p>
<ol>
<li>如果是Boolean值，true和false将分别被转换为1和0。</li>
<li>如果是数字值，只是简单的传入和返回。</li>
<li>如果是null值，返回0。</li>
<li>如果是undefined，返回NaN。</li>
<li>如果是字符串，遵循下列规则<ul>
<li>如果字符串中只包含数字（包括前面带加号或头号的情况），则将其转换为十进制数值，即”1”会变成1，”123”会变成123，而”011”会变成11（注意：前导的零被忽略了）</li>
<li>如果字符串中包含有效的浮点格式，如”1.1”，则将其转换为对应的浮点数值（同样，也会忽略前导零）</li>
<li>如果字符串中包含有效的十六进制格式，例如”Oxf”，则将其转换为相同大小的十进制整数值</li>
<li>如果字符串是空的（不包含任何字符），则将其转换为0</li>
<li>如果字符串中包含除上述格式之外的字符，则将其转换为NaN。</li>
</ul>
</li>
<li>如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符串值。</li>
</ol>
<p>由于Number()函数在转换字符串时比较复杂而且不够合理，因此在处理整数的时候更常用的是parseInt()函数。parseInt()函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt()就会返回NaN；也就是说，用parseInt()转换空字符串会返回NaN（Number()对空字符返回0）。如果第一个字符是数字字符，parseInt()会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。例如，”1234blue”会被转换为1234，因为”blue”会被完全忽略。类似地，”22.5”会被转换为22，因为小数点并不是有效的数字字符。<br>如果字符串中的第一个字符是数字字符，parseInt()也能够识别出各种整数格式（即前面讨论的十进制、八进制和十六进制数）。也就是说，如果字符串以”Ox”开头且后跟数字字符，就会将其当作一个十六进制整数；如果字符串以”0”开头且后跟数字字符，则会将其当作一个八进制数来解析。</p>
<p>在ECMAScript 3 JavaScript引擎中，”070”被当成八进制字面量，因此转换后的值是十进制的56。而在ECMAScript 5 JavaScript引擎中，parseInt()已经不具有解析八进制值的能力，因此前导的零会被认为无效，从而将这个值当成”0”，结果就得到十进制的0。在ECMAScript5中，即使是在严格模式下也会如此。</p>
<p>为了消除在使用parseInt()函数时可能导致的上述困惑，可以为这个函数提供第二个参数：转换时使用的基数（即多少进制）。如果知道要解析的值是十六进制格式的字符串，那么指定基数16作为第二个参数，可以保证得到正确的结果，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="built_in">parseInt</span>（<span class="string">"OxAF"</span>, <span class="number">16</span>）； <span class="comment">//175</span></div></pre></td></tr></table></figure>
<p>实际上，如果指定了16作为第二个参数，字符串可以不带前面的”Ox”，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">"AF"</span>, <span class="number">16</span>); <span class="comment">//175</span></div><div class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">"AF"</span>);     <span class="comment">//NaN</span></div></pre></td></tr></table></figure>
<p>这个例子中的第一个转换成功了，而第二个则失败了。差别在于第一个转换传入了基数，明确告诉parseInt()要解析一个十六进制格式的字符串；而第二个转换发现第一个字符不是数字字符，因此就自动终止了。</p>
<p>不指定基数意味着让parseInt()决定如何解析输入的字符串，因此为了避免错误的解析，我们建议无论在什么情况下都明确指定基数。</p>
<p>与parseInt()函数类似，parseFloat()也是从第一个字符（位置0）开始解析每个字符。而且也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的第一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。举例来说，”22.34.5”将会被转换为22.34。</p>
<p>除了第一个小数点有效之外，parseFloat()与parseInt()的第二个区别在于它始终都会忽略前导的零。parseFloat()可以识别前面讨论过的所有浮点数值格式，也包括十进制整数格式。但十六进制格式的字符串则始终会被转换成0。由于parseFloat()只解析十进制值，因此它没有用第二个参数指定基数的用法。最后还要注意一点：如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后都是零），parseFloat()会返回整数。以下是使用parseFloat()转换数值的几个典型示例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseFloat</span>(<span class="string">"1234blue"</span>);  <span class="comment">//1234(整数)</span></div><div class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseFloat</span>(<span class="string">"0xA"</span>);       <span class="comment">//0</span></div><div class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseFloat</span>(<span class="string">"22.5"</span>);      <span class="comment">//22.5</span></div><div class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseFloat</span>(<span class="string">"22.34.5"</span>);   <span class="comment">//22.34</span></div><div class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseFloat</span>(<span class="string">"0908.5"</span>);    <span class="comment">//908.5</span></div><div class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseFloat</span>(<span class="string">"3.125e7"</span>);   <span class="comment">//31250000</span></div></pre></td></tr></table></figure>
<h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由双引号（”）或单引号（’）表示。用双引号表示的字符串和用单引号表示的字符串完全相同。</p>
<h4 id="字符字面量"><a href="#字符字面量" class="headerlink" title="字符字面量"></a>字符字面量</h4><p>String数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符，或者具有其他用途的字符。这些字符字面量如下表所示：<br>| 字面量 | 含义                                                 |<br>|——–|——————————————————|<br>| \n     | 换行                                                 |<br>| \t     | 制表                                                 |<br>| \b     | 空格                                                 |<br>| \r     | 回车                                                 |<br>| \f     | 进纸                                                 |<br>| \     | 斜杠                                                 |<br>| \’     | 单引号（’），在用单引号表示的字符串中使用            |<br>| \”     | 双引号（”），在用双引号表示的字符串中使用            |<br>| \xnn   | 以十六进制代码nn表示的一个字符（其中n为0~F）         |<br>| \unnnn | 以十六进制代码nnnn表示的一个Unicode字符（其中n为0~F）|<br>任何字符串的长度都可以通过访问其length属性取得。</p>
<h4 id="字符串的特点"><a href="#字符串的特点" class="headerlink" title="字符串的特点"></a>字符串的特点</h4><p>ECMAScript中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。</p>
<p>要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的toString()方法。<br>数值、布尔值、对象和字符串值（没错，每个字符串也都有一个toString()方法，该方法返回字符串的一个副本）都有toString()方法。但null和undefined值没有这个方法。</p>
<p>数情况下，调用toString()方法不必传递参数。但是，在调用数值的toString()方法时，可以传递一个参数：输出数值的基数。默认情况下，toString()方法以十进制格式返回数值的字符串表示。而通过传递基数，toString()可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格式表示的字符串值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</div><div class="line">alert(num.toString());   <span class="comment">//"10"</span></div><div class="line">alert(num.toString(<span class="number">2</span>));  <span class="comment">//"1010"</span></div><div class="line">alert(num.toString(<span class="number">8</span>));  <span class="comment">//"12"</span></div><div class="line">alert(num.toString(<span class="number">9</span>));  <span class="comment">//"10"</span></div><div class="line">alert(num.toString(<span class="number">16</span>)); <span class="comment">//"a"</span></div></pre></td></tr></table></figure></p>
<p>在不知道要转换的值是不是null或undefined的情况下，还可以使用转型函数String()，这个函数能够将任何类型的值转换为字符串。String()函数遵循下列转换规则：</p>
<ol>
<li>如果值有toString()方法，则调用该方法（没有参数）并返回相应的结果；</li>
<li>如果值是null，则返回”null”；</li>
<li>如果值是undefined，则返回”undefined”。</li>
</ol>
<blockquote>
<p>要把某个值转换为字符串，可以使用加号操作符（3.5节讨论）把它与一个字符串（””）加在一起。</p>
</blockquote>
<h3 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h3><p>CMAScript中的对象其实就是一组数据和功能的集合。对象可以通过执行new操作符后跟要创建的对象类型的名称来创建。而创建Object类型的实例并为其添加属性和（或）方法，就可以创建自定义对象，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()；</div></pre></td></tr></table></figure>
<p>这个语法与Java中创建对象的语法相似；但在ECMAScript中，如果不给构造函数传递参数，则可以省略后面的那一对圆括号。也就是说，在像前面这个示例一样不传递参数的情况下，完全可以省略那对圆括号（但这不是推荐的做法）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>； <span class="comment">//有效，但不推荐省略圆括号</span></div></pre></td></tr></table></figure>
<p>仅仅创建Object的实例并没有什么用处，但关键是要理解一个重要的思想：即在ECMAScript中，（就像Java中的java.lang.Object对象一样）Object类型是所有它的实例的基础。换句话说，Object类型所具有的任何属性和方法也同样存在于更具体的对象中。</p>
<p>Object的每个实例都具有下列属性和方法:</p>
<ul>
<li>constructor：保存着用于创建当前对象的函数。</li>
<li>hasOwnProperty（propertyName）：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。</li>
<li>isPrototypeOf（object）：用于检查传入的对象是否是另一个对象的原型。</li>
<li>propertyIsEnumerable（propertyName）：用于检查给定的属性是否能够使用for-in语句（本章后面将会讨论）来枚举。</li>
<li>toLocaleString():返回对象的字符串表示，该字符串与执行环境的地区对应。</li>
<li>toString()：返回对象的字符串表示。</li>
<li>valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。</li>
</ul>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><ul>
<li>操作符包括算数操作符，位操作符，关系操作符和相等操作符。</li>
<li>他们可以适用于很多值，包括字符串，数字值，布尔值，甚至对象。</li>
<li>在应用于对象时，通常会调用对象的valueOf()和(或)toString()方法。</li>
</ul>
<h3 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h3><p>只能操作一个值的操作符叫做一元操作符。一元操作符是ECMAScript中最简单的操作符。</p>
<h4 id="递增和递减操作符"><a href="#递增和递减操作符" class="headerlink" title="递增和递减操作符"></a>递增和递减操作符</h4><ul>
<li>前置++ =&gt; ++a</li>
<li>后置++ =&gt; a++</li>
<li>前置– =&gt; –a</li>
<li>后置– =&gt; a–<blockquote>
<p>效果同Ｃ语言<br>不同的是，这四个操作符对任何值都适用。</p>
</blockquote>
</li>
</ul>
<ul>
<li>在应用于一个<strong>包含有效数字字符的字符串</strong>时，先将其转换为数字值，再执行加减1的操作。字符串变量变成数值变量。</li>
<li>在应用于一个<strong>不包含有效数字字符的字符串</strong>时，将变量的值设置为NaN。字符串变量变成数值变量。</li>
<li>在应用于布尔值<strong>false</strong>时，先将其转换为0再执行加减1的操作。布尔值变量变成数值变量。</li>
<li>在应用于布尔值<strong>true</strong>时，先将其转换为1再执行加减1的操作。布尔值变量变成数值变量。</li>
<li>在应用于<strong>浮点数值</strong>时，执行加减1的操作。</li>
<li>在应用于<strong>对象</strong>时，先调用对象的valueOf()方法以取得一个可供操作的值。然后对该值应用前述规则。如果结果是NaN，则在调用toString()方法后再应用前述规则。对象变量变成数值变量。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="string">'2'</span>;</div><div class="line"><span class="keyword">var</span> s2 = <span class="string">'z'</span>;</div><div class="line"><span class="keyword">var</span> s3 = <span class="string">'123z'</span>;</div><div class="line"><span class="keyword">var</span> b1 = <span class="literal">false</span>;</div><div class="line"><span class="keyword">var</span> b2 = <span class="literal">true</span>;</div><div class="line"><span class="keyword">var</span> f = <span class="number">1.1</span>;</div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  <span class="attr">valueOf</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">s1++;    <span class="comment">// s1 == 3</span></div><div class="line">s2++;    <span class="comment">// s2 == NaN</span></div><div class="line">s3++;    <span class="comment">// s3 == NaN</span></div><div class="line">b1--;    <span class="comment">// b1 == -1</span></div><div class="line">b2--;    <span class="comment">// b2 == 0</span></div><div class="line">f--;     <span class="comment">// f  == 0.100000000000009</span></div><div class="line">o--;     <span class="comment">// o == -2</span></div></pre></td></tr></table></figure>
<h4 id="一元加和减操作符"><a href="#一元加和减操作符" class="headerlink" title="一元加和减操作符"></a>一元加和减操作符</h4><ul>
<li>一元加减操作符作用于数值，同Ｃ语言。</li>
<li>一元加操作符作用于数值非数值，等同于Number()转型函数。</li>
<li>一元减操作符作用于数值非数值，等同于一元加操作符最后将其转换成负数。</li>
</ul>
<h3 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h3><ul>
<li>按位非（NOT）<br>按位非操作符由一个波浪线（~）表示，执行按位非的结果就是返回数值的反码。</li>
<li>按位与（AND）<br>按位与操作符由一个和号字符（&amp;）表示，它有两个操作符数。</li>
<li>按位或（OR）<br>按位或操作符由一个竖线符号（|）表示，同样也有两个操作数。</li>
<li>按位异或（XOR）<br>按位异或操作符由一个插入符号（^）表示，也有两个操作数。</li>
<li>左移<br>左移操作符由两个小于号（&lt;&lt;）表示，这个操作符会将数值的所有位向左移动指定的位数。右侧空出用0补充。（左移不影响符号位）</li>
<li>有符号的右移<br>有符号的右移操作符由两个大于号（&gt;&gt;）表示，这个操作符会将数值向右移动，但保留符号位（即正负号标记）。</li>
<li>无符号右移<br>无符号右移操作符由3个大于号（&gt;&gt;&gt;）表示，这个操作符会将数值的所有32位都向右移动。对正数来说，无符号右移的结果与有符号右移相同。对于负数来说则不同。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">-64</span>;     <span class="comment">// 二进制11111111111111111111111111000000</span></div><div class="line"><span class="keyword">var</span> b = a &gt;&gt;&gt; <span class="number">5</span>; <span class="comment">// 二进制00000111111111111111111111111111</span></div></pre></td></tr></table></figure>
<h3 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h3><ul>
<li><p>!</p>
<ul>
<li>如果操作数是一个对象，返回false；</li>
<li>如果操作数是一个空字符串，返回true；</li>
<li>如果操作数是一个非空字符串，返回false；</li>
<li>如果操作数是数值0，返回true； 如果操作数是任意非0数值（包括Infinity），返回false;</li>
<li>如果操作数是null，返回true；</li>
<li>如果操作数是NaN，返回true； 如果操作数是undefined，返回true。<blockquote>
<p><code>!!</code> 等同于 <code>Boolean()</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p>&amp;&amp;    </p>
<ul>
<li>如果第一个操作数是对象，则返回第二个操作数；</li>
<li>如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才会返回该对象；</li>
<li>如果两个操作数都是对象，则返回第二个操作数；</li>
<li>如果有一个操作数是null，则返回null；</li>
<li>如果有一个操作数是NaN，则返回NaN；</li>
<li>如果有一个操作数是undefined，则返回undefined。<blockquote>
<p>不能在逻辑与操作中使用未定义的值</p>
</blockquote>
</li>
</ul>
</li>
<li><p>||</p>
<ul>
<li>如果第一个操作数是对象，则返回第一个操作数；</li>
<li>如果第一个操作数的求值结果为false，则返回第二个操作数；</li>
<li>如果两个操作数都是对象，则返回第一个操作数；</li>
<li>如果两个操作数都是null，则返回null；</li>
<li>如果两个操作数都是NaN，则返回NaN；</li>
<li>如果两个操作数都是undefined，则返回undefined。<blockquote>
<p>可以利用逻辑或的这一行为来避免为变量赋null或undefined值。<br>var myObject = preferredObject || backupObject;</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h3><ul>
<li>*<ul>
<li>如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity；</li>
<li>如果有一个操作数是NaN，则结果是NaN；</li>
<li>如果是Infinity与0相乘，则结果是NaN;</li>
<li>如果是Infinity与非0数值相乘，则结果是Infinity或-Infinity，取决于有符号操作数的符号；</li>
<li>如果是Infinity与Infinity相乘，则结果是Infinity；</li>
<li>如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。</li>
</ul>
</li>
<li>/<ul>
<li>如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果商超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity；</li>
<li>如果有一个操作数是NaN，则结果是NaN；</li>
<li>如果是Infinity被Infinity除，则结果是NaN;</li>
<li>如果是零被零除，则结果是NaN;</li>
<li>如果是非零的有限数被零除，则结果是Infinity或-Infinity，取决于有符号操作数的符号；</li>
<li>如果是Infinity被任何非零数值除，则结果是Infinity或-Infinity，取决于有符号操作数的符号；</li>
<li>如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。</li>
</ul>
</li>
<li>%<ul>
<li>如果操作数都是数值，执行常规的除法计算，返回除得的余数；</li>
<li>如果被除数是无穷大值而除数是有限大的数值，则结果是NaN；</li>
<li>如果被除数是有限大的数值而除数是零，则结果是NaN；</li>
<li>如果是Infinity被Infinity除，则结果是NaN;</li>
<li>如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；</li>
<li>如果被除数是零，则结果是零；</li>
<li>如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。</li>
</ul>
</li>
</ul>
<h3 id="加减操作符"><a href="#加减操作符" class="headerlink" title="加减操作符"></a>加减操作符</h3><ul>
<li><p>+</p>
<ul>
<li>如果有一个操作数是NaN，则结果是NaN；</li>
<li>如果是Infinity加Infinity，则结果是Infinity；</li>
<li>如果是-Infinity加-Infinity，则结果是-Infinity；</li>
<li>如果是Infinity加-Infinity，则结果是NaN；</li>
<li>如果是+0加+0，则结果是+0；</li>
<li>如果是-0加-0，则结果是-0；</li>
<li>如果是+0加-0，则结果是+0。</li>
<li>如果有一个操作数是字符串：<ul>
<li>如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；</li>
<li>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。<blockquote>
<p>如果有一个操作数是对象、数值或布尔值，则调用它们的toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于undefined和null，则分别调用String()函数并取得字符串”undefined”和”null”。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>-</p>
<ul>
<li>如果两个操作符都是数值，则执行常规的算术减法操作并返回结果；</li>
<li>如果有一个操作数是NaN，则结果是NaN；</li>
<li>如果是Infinity减Infinity，则结果是NaN；</li>
<li>如果是-Infinity减-Infinity，则结果是NaN；</li>
<li>如果是Infinity减-Infinity，则结果是Infinity；</li>
<li>如果是-Infinity减Infinity，则结果是-Infinity；</li>
<li>如果是+0减+0，则结果是+0；</li>
<li>如果是+0减-0，则结果是-0；</li>
<li>如果是-0减-0，则结果是+0；</li>
<li>如果有一个操作数是字符串、布尔值、null或undefined，则先在后台调用Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是NaN，则减法的结果就是NaN;</li>
<li>如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值。如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值。</li>
</ul>
</li>
</ul>
<h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><ul>
<li>如果两个操作数都是数值，则执行数值比较。</li>
<li>如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。</li>
<li>如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。</li>
<li>如果一个操作数是对象，则调用这个对象的valueOf()方法，用得到的结果按照前面的规则执行比较。如果对象没有valueOf()方法，则调用toString()方法，并用得到的结果根据前面的规则执行比较。</li>
<li>如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。</li>
</ul>
<h3 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h3><ul>
<li><p>== / !=</p>
<ul>
<li>如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；</li>
<li>如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；</li>
<li>如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较；</li>
<li>null和undefined是相等的。</li>
<li>要比较相等性之前，不能将null和undefined转换成其他任何值。</li>
<li>如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。</li>
<li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false。</li>
</ul>
</li>
<li><p>=== / !==</p>
<ul>
<li>除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。</li>
</ul>
</li>
</ul>
<h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3><ul>
<li><code>variable = boolean_expression ？ true_value : false_value;</code></li>
</ul>
<h3 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h3><ul>
<li>=</li>
<li>+=</li>
<li>-=</li>
<li>*=</li>
<li>/=</li>
<li>%=</li>
<li>&lt;&lt;=</li>
<li><blockquote>
<blockquote>
<p>=</p>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>=</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
<blockquote>
<p>设计这些操作符的主要目的就是简化赋值操作。使用它们不会带来任何性能的提升。</p>
</blockquote>
<h3 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h3><ul>
<li>使用逗号操作符可以在一条语句中执行多个操作；</li>
<li>逗号操作符还可以用于赋值。在用于赋值时，逗号操作符总会返回表达式中的最后一项。</li>
</ul>
<h2 id="流控制语句"><a href="#流控制语句" class="headerlink" title="流控制语句"></a>流控制语句</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p><code>if（condition）statement1 else statement2</code><br>其中的condition（条件）可以是任意表达式；而且对这个表达式求值的结果不一定是布尔值。ECMAScript会自动调用Boolean()转换函数将这个表达式的结果转换为一个布尔值。如果对condition求值的结果是true，则执行statementl（语句1），如果对condition求值的结果是false，则执行statement2（语句2）。</p>
<h3 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h3><p>do-while语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。</p>
<p>像do-while这种后测试循环语句最常用于循环体中的代码至少要被执行一次的情形。</p>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>while语句属于前测试循环语句，也就是说，在循环体内的代码被执行之前，就会对出口条件求值。</p>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>for语句也是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。</p>
<h3 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h3><p>for-in语句是一种精准的迭代语句，可以用来枚举对象的属性。</p>
<p>ECMAScript对象的属性没有顺序。因此，通过for-in循环输出的属性名的顺序是不可预测的。具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。</p>
<p>但是，如果表示要迭代的对象的变量值为null或undefined，for-in语句会抛出错误。ECMAScript5更正了这一行为；对这种情况不再抛出错误，而只是不执行循环体。为了保证最大限度的兼容性，建议在使用for-in循环之前，先检测确认该对象的值不是null或undefined。</p>
<h3 id="label"><a href="#label" class="headerlink" title="label"></a>label</h3><p>使用label语句可以在代码中添加标签，以便将来使用。</p>
<p>标签可以在将来由break或continue语句引用。</p>
<p>加标签的语句一般都要与for语句等循环语句配合使用。</p>
<h3 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h3><p>break语句会立即退出循环，强制继续执行循环后面的语句。而continue语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。</p>
<h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>with语句的作用是将代码的作用域设置到一个特定的对象中。</p>
<p>定义with语句的目的主要是为了简化多次编写同一个对象的工作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> qs = location.search.substring(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> hostName = location.hostname;</div><div class="line"><span class="keyword">var</span> url = location.href;</div><div class="line"></div><div class="line"><span class="comment">// 等价于</span></div><div class="line"><span class="keyword">with</span>(location) &#123;</div><div class="line">    <span class="keyword">var</span> qs = search.substring(<span class="number">1</span>);</div><div class="line">    <span class="keyword">var</span> hostName = hostname;</div><div class="line">    <span class="keyword">var</span> url = href;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>严格模式下不允许使用with语句，否则将视为语法错误。</p>
<p>由于大量使用with语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用with语句。</p>
</blockquote>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>作用同C语言，不同的是case语句可以是任意类型的常量，变量，表达式。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>ECMAScript中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）。</li>
<li>在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。</li>
<li>命名的参数只提供便利，但不是必需的。</li>
<li>arguments对象可以与命名参数一起使用。</li>
<li>修改arguments中的值会改变命名参数对应的值。</li>
<li>修改命名参数不会改变arguments中对应的值。</li>
<li>没有传递值的命名参数将自动被赋予undefined值。</li>
<li>严格模式对如何使用argumetns对象做出了一些限制。<ul>
<li>修改arguments的值，将不会修改对应命名参数的值。</li>
<li>重写arguments的值会导致语法错误（代码将不会执行）。</li>
</ul>
</li>
<li>ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数。</li>
<li>没有重载，后定义函数会覆盖先定义函数。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="Lisiur Day" />
          <p class="site-author-name" itemprop="name">Lisiur Day</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">33</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lisiur Day</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
