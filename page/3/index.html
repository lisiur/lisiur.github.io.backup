<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Lisiur" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Lisiur">
<meta property="og:url" content="http://Lisiur.com/page/3/index.html">
<meta property="og:site_name" content="Lisiur">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lisiur">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Lisiur </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Lisiur</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/01/JavaScript基本概念/" itemprop="url">
                  JavaScript基本概念
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-01T10:28:55+08:00" content="2016-08-01">
              2016-08-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/javascript笔记/" itemprop="url" rel="index">
                    <span itemprop="name">javascript笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>ECMAScript的语法大量借鉴了C及其他类C语言（如Java和Perl）的语法。</p>
<h3 id="区分大小写"><a href="#区分大小写" class="headerlink" title="区分大小写"></a>区分大小写</h3><p>要理解的第一个概念就是ECMAScriptj中的一切（变量、函数名和操作符）都区分大小写。这也就意味着，变量名test和变量名Test分别表示两个不同的变量，而函数名不能使用typeof，因为它是一个关键字（3.2节介绍关键字），但typeOf则完全可以是一个有效的函数名。</p>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。标识符可以是按照下列格式规则组合起来的一或多个字符：</p>
<ol>
<li>第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；</li>
<li>其他字符可以是字母、下划线、美元符号或数字。</li>
</ol>
<p>标识符中的字母也可以包含扩展的ASCII或Unicode字母字符（如A和Æ），但我们不推荐这样做。</p>
<p>按照惯例，ECMAScript标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个有意义的单词的首字母大写，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">firstSecond</div><div class="line">myCar</div><div class="line">doSomethingImportant</div></pre></td></tr></table></figure></p>
<p>虽然没有谁强制要求必须采用这种格式，但为了与ECMAScript内置的函数和对象命名格式保持一致，可以将其当作一种最佳实践。</p>
<p> 不能把关键字、保留字、true、false和null用作标识符。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>ECMAScript使用C风格的注释，包括单行注释和块级注释。单行注释以两个斜杠开头，如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//单行注释</span></div></pre></td></tr></table></figure></p>
<p>块级注释以一个斜杠和一个星号（/<em>）开头，以一个星号和一个斜杠（</em>/）结尾，如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> *这是一个块级注释</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<p>虽然上面注释中的第二和第三行都以一个星号开头，但这不是必需的。之所以添加那两个星号，纯粹是为了提高注释的可读性（这种格式在企业级应用程序中极其常见）。</p>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>ECMAScript 5引入了严格模式（strict mode）的概念。严格模式是为JavaScript定义了一种不同的解析与执行模型。在严格模式下，ECMAScript 3中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div></pre></td></tr></table></figure></p>
<p>这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示（pragma），用于告诉支持的JavaScript引擎切换到严格模式。这是为不破坏ECMAScript 3语法而特意选定的语法。</p>
<p>在函数内部的上方包含这条编译指示，也可以指定函数在严格模式下执行：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="string">"use strict;"</span></div><div class="line">	<span class="comment">//函数体</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>严格模式下，JavaScript的执行结果会有很大不同，因此本书将会随时指出严格模式下的区别。支持严格模式的浏览器包括IE10+、Firefox 4+、Safari 5.1+、Opera 12+和Chrome。</p>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>ECMAScript中的语句以一个分号结尾；如果省略分号，则由解析器确定语句的结尾，如下例所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = a + b <span class="comment">//正确，但不推荐</span></div><div class="line"><span class="keyword">var</span> diff = a-b; <span class="comment">//正确，k推荐</span></div></pre></td></tr></table></figure></p>
<p>虽然语句结尾的分号不是必需的，但我们建议任何时候都不要省略它。因为加上这个分号可以避免很多错误（例如不完整的输入），开发人员也可以放心地通过删除多余的空格来压缩ECMAScript代码（代码行结尾处没有分号会导致压缩错误）。另外，加上分号也会在某些情况下增进代码的性能，因为这样解析器就不必再花时间推测应该在哪里插入分号了。</p>
<p>可以使用C风格的语法把多条语句组合到一个代码块中，即代码块以左花括号（{）开头，以右花括号（}）结尾：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (test) &#123;</div><div class="line">    test =<span class="literal">false</span>;</div><div class="line">    alert(test);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然条件控制语句（如if语句）只在执行多条语句的情况下才要求使用代码块，但最佳实践是始终在控制语句中使用代码块——即使代码块中只有一条语句，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (test) </div><div class="line">    alert(test); <span class="comment">//有效，但不推荐</span></div><div class="line"><span class="keyword">if</span> (test) &#123;</div><div class="line">    alert(test); <span class="comment">//有效，推荐</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在控制语句中使用代码块可以让编码意图更加清晰，而且也能降低修改代码时出错的几率。</p>
<h3 id="关键字和保留字"><a href="#关键字和保留字" class="headerlink" title="关键字和保留字"></a>关键字和保留字</h3><p>ECMA-262描述了一组具有特定用途的关键字，这些关键字可用于表示控制语句的开始或结束，或者用于执行特定操作等。按照规则，关键字也是语言保留的，不能用作标识符。以下就是ECMAScript的全部关键字（带*号上标的是第5版新增的关键字）：</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>关键字</th>
<th>关键字</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>break</td>
<td>do</td>
<td>instanceof</td>
<td>typeof</td>
</tr>
<tr>
<td>case</td>
<td>else</td>
<td>new</td>
<td>var</td>
</tr>
<tr>
<td>catch</td>
<td>finally</td>
<td>return</td>
<td>void</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>switch</td>
<td>while</td>
</tr>
<tr>
<td>debugger*</td>
<td>function</td>
<td>this</td>
<td>with</td>
</tr>
<tr>
<td>default</td>
<td>if</td>
<td>throw</td>
<td></td>
</tr>
<tr>
<td>delete</td>
<td>in</td>
<td>try</td>
</tr>
</tbody>
</table>
<p>ECMA-262还描述了另外一组不能用作标识符的保留字。尽管保留字在这门语言中还没有任何特定的用途，但它们有可能在将来被用作关键字。以下是ECMA-262第3版定义的全部保留字：</p>
<table>
<thead>
<tr>
<th>保留字</th>
<th>保留字</th>
<th>保留字</th>
<th>保留字</th>
</tr>
</thead>
<tbody>
<tr>
<td>abstract</td>
<td>enum</td>
<td>int</td>
<td>short</td>
</tr>
<tr>
<td>boolean</td>
<td>export</td>
<td>interface</td>
<td>static</td>
</tr>
<tr>
<td>byte</td>
<td>extends</td>
<td>long</td>
<td>super</td>
</tr>
<tr>
<td>char</td>
<td>final</td>
<td>native</td>
<td>synchronized</td>
</tr>
<tr>
<td>class</td>
<td>float</td>
<td>package</td>
<td>throws</td>
</tr>
<tr>
<td>const</td>
<td>goto</td>
<td>private</td>
<td>transient</td>
</tr>
<tr>
<td>debugger</td>
<td>implements</td>
<td>protected</td>
<td>volatile</td>
</tr>
<tr>
<td>double</td>
<td>important</td>
<td>public</td>
<td>volatile</td>
</tr>
</tbody>
</table>
<p>第5版把在非严格模式下运行时的保留字缩减为下列这些：</p>
<table>
<thead>
<tr>
<th>保留字</th>
<th>保留字</th>
<th>保留字</th>
<th>保留字</th>
</tr>
</thead>
<tbody>
<tr>
<td>calss</td>
<td>enum</td>
<td>extends</td>
<td>super</td>
</tr>
<tr>
<td>const</td>
<td>export</td>
<td>import</td>
</tr>
</tbody>
</table>
<p>在严格模式下，第5版还对以下保留字施加了限制：</p>
<table>
<thead>
<tr>
<th>保留字</th>
<th>保留字</th>
<th>保留字</th>
</tr>
</thead>
<tbody>
<tr>
<td>implements</td>
<td>package</td>
<td>public</td>
</tr>
<tr>
<td>interface</td>
<td>private</td>
<td>static</td>
</tr>
<tr>
<td>let</td>
<td>protected</td>
<td>yield</td>
</tr>
</tbody>
</table>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>ECMAScript的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值的占位符而已。定义变量时要使用var操作符（注意var是一个关键字），后跟变量名（即一个标识符），如下所示：</p>
<pre><code>var message;
</code></pre><p>这行代码定义了一个名为message的变量，该变量可以用来保存任何值（像这样未经过初始化的变量，会保存一个特殊的值——undefined，相关内容将在3.4节讨论）。ECMAScript也支持直接初始化变量，因此在定义变量的同时就可以设置变量的值，如下所示：</p>
<pre><code>var message =&quot;hi&quot;；
</code></pre><p>在此，变量message中保存了一个字符串值”hi”。像这样初始化变量并不会把它标记为字符串类型；初始化的过程就是给变量赋一个值那么简单。因此，可以在修改变量值的同时修改值的类型，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">"hi"</span>;</div><div class="line">message = <span class="number">100</span>;      <span class="comment">//有效，不推荐</span></div></pre></td></tr></table></figure>
<p>在这个例子中，变量message一开始保存了一个字符串值”hi”，然后该值又被一个数字值100取代。虽然我们不建议修改变量所保存值的类型，但这种操作在ECMAScript中完全有效。</p>
<p>有一点必须注意，即使用var操作符定义的变量将成为定义该变量的作用域中的局部变量。也就是说，如果在函数中使用var定义一个变量，那么这个变量在函数退出后就会被销毁，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> message = <span class="string">"hi"</span>; <span class="comment">//局部变量</span></div><div class="line">&#125;</div><div class="line">test();</div><div class="line">alert(message); <span class="comment">//错误！</span></div></pre></td></tr></table></figure>
<p>这里，变量message是在函数中使用var定义的。当函数被调用时，就会创建该变量并为其赋值。而在此之后，这个变量又会立即被销毁，因此例子中的下一行代码就会导致错误。不过，可以像下面这样省略var操作符，从而创建一个全局变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    message = <span class="string">"hi"</span>; <span class="comment">//全局变量</span></div><div class="line">&#125;</div><div class="line">test();</div><div class="line">alert(message); <span class="comment">// "hi"</span></div></pre></td></tr></table></figure>
<p>这个例子省略了var操作符，因而message就成了全局变量。这样，只要调用过一次test()函数，这个变量就有了定义，就可以在函数外部的任何地方被访问到。</p>
<p>虽然省略var操作符可以定义全局变量，但这也不是我们推荐的做法。因为在局部作用域中定义的全局变量很难维护，而且如果有意地忽略了var操作符，也会由于相应变量不会马上就有定义而导致不必要的混乱。给未经声明的变量赋值在严格模式下会导致抛出ReferenceError错误。<br>可以使用一条语句定义多个变量，只要像下面这样把每个变量（初始化或不初始化均可）用逗号分隔开即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">"hi"</span>,</div><div class="line">    found = <span class="literal">false</span>,</div><div class="line">    age = <span class="number">29</span>;</div></pre></td></tr></table></figure>
<p>这个例子定义并初始化了3个变量。同样由于ECMAScript是松散类型的，因而使用不同类型初始化变量的操作可以放在一条语句中来完成。虽然代码里的换行和变量缩进不是必需的，但这样做可以提高可读性。</p>
<p>在严格模式下，不能定义名为eval或arguments的变量，否则会导致语法错误。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>ECMAScript中有5种简单数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number和String。还有1种复杂数据类型——Object，Object本质上是由一组无序的名值对组成的。ECMAScript不支持任何创建自定义类型的机制，而所有值最终都将是上述6种数据类型之一。乍一看，好像只有6种数据类型不足以表示所有数据；但是，由于ECMAScript数据类型具有动态性，因此的确没有再定义其他数据类型的必要了。</p>
<h3 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h3><p>鉴于ECMAScript是松散类型的，因此需要有一种手段来检测给定变量的数据类型——typeof就是负责提供这方面信息的操作符。对一个值使用typeof操作符可能返回下列某个字符串：</p>
<ol>
<li>“undefined”——如果这个值未定义；</li>
<li>“boolean”——如果这个值是布尔值；</li>
<li>“string”——如果这个值是字符串；</li>
<li>“number”——如果这个值是数值；</li>
<li>“object”——如果这个值是对象或null；</li>
<li>“function”——如果这个值是函数。</li>
</ol>
<p>有些时候，typeof操作符会返回一些令人迷惑但技术上却正确的值。比如，调用typeof null会返回”object”，因为特殊值null被认为是一个空的对象引用。Safari 5及之前版本、Chrome 7及之前版本在对正则表达式调用typeof操作符时会返回“function”，而其他浏览器在这种情况下会返回”object”。</p>
<p>从技术角度讲，函数在ECMAScript中是对象，不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过typeof操作符来区分函数和其他对象是有必要的。</p>
<h3 id="Undefined类型"><a href="#Undefined类型" class="headerlink" title="Undefined类型"></a>Undefined类型</h3><p>Undefined类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message;</div><div class="line">alert(message == <span class="literal">undefined</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>一般而言，不存在需要显式地把一个变量设置为undefined值的情况。字面值undefined的主要目的是用于比较，而ECMA-262第3版之前的版本中并没有规定这个值。第3版引入这个值是为了正式区分空对象指针与未经初始化的变量。<br>不过，包含undefined值的变量与尚未定义的变量还是不一样的。看看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message;</div><div class="line">alert(message);        <span class="comment">// "undefined"</span></div><div class="line">alert(age);            <span class="comment">// error</span></div><div class="line">alert(<span class="keyword">typeof</span> message); <span class="comment">// "undefined"</span></div><div class="line">alert(<span class="keyword">typeof</span> age);     <span class="comment">// "undefined"</span></div></pre></td></tr></table></figure>
<p>结果表明，对未初始化和未声明的变量执行typeof操作符都返回了undefined值；这个结果有其逻辑上的合理性。因为虽然这两种变量从技术角度看有本质区别，但实际上无论对哪种变量也不可能执行真正的操作。</p>
<blockquote>
<p>即便未初始化的变量会自动被赋予undefined值，但显式地初始化变量依然是明智的选择。如果能够做到这一点，那么当typeof操作符返回”undefined”值时，我们就知道被检测的变量还没有被声明，而不是尚未初始化。</p>
</blockquote>
<h3 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h3><p>Null类型是第二个只有一个值的数据类型，这个特殊的值是null。从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null值时会返回”object”的原因。</p>
<p>如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。这样一来，只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的引用了。</p>
<p>实际上，undefined值是派生自null值的，因此ECMA-262规定对它们的相等性测试要返回true。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(<span class="literal">null</span> == <span class="literal">undefined</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>尽管null和undefined有这样的关系，但它们的用途完全不同。如前所述，无论在什么情况下都没有必要把一个变量的值显式地设置为undefined，可是同样的规则对null却不适用。换句话说，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。这样做不仅可以体现null作为空对象指针的惯例，而且也有助于进一步区分null和undefined。</p>
<h3 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h3><p>Boolean类型是ECMAScript中使用得最多的一种类型，该类型只有两个字面值：true和false。这两个值与数字值不是一回事，因此true不一定等于1，而false也不一定等于0。</p>
<p>需要注意的是，Boolean类型的字面值true和false是区分大小写的。也就是说，True和False（以及其他的混合大小写形式）都不是Boolean值，只是标识符。</p>
<p>虽然Boolean类型的字面值只有两个，但ECMAScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用转型函数Boolean()。</p>
<p>可以对任何数据类型的值调用Boolean()函数，而且总会返回一个Boolean值。至于返回的这个值是true还是false，取决于要转换值的数据类型及其实际值。下表给出了各种数据类型及其对应的转换规则。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>转换成true的值</th>
<th>转换成false的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>任何非空字符串</td>
<td>‘’和””</td>
</tr>
<tr>
<td>Number</td>
<td>任何非零数字值（包括无穷大）</td>
<td>0和NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任何对象</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td>n/a</td>
<td>undefined</td>
</tr>
</tbody>
</table>
<h3 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h3><p>Number类型应该是ECMAScript中最令人关注的数据类型了，这种类型使用IEEE754格式来表示整数和浮点数值（浮点数值在某些语言中也被称为双精度数值）。为支持各种数值类型，ECMA-262定义了不同的数值字面量格式。</p>
<p>最基本的数值字面量格式是十进制整数，十进制整数可以像下面这样直接在代码中输入：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> intNum = <span class="number">55</span>; <span class="comment">// 整数</span></div></pre></td></tr></table></figure>
<p>除了以十进制表示外，整数还可以通过八进制（以8为基数）或十六进制（以16为基数）的字面值来表示。其中，八进制字面值的第一位必须是零（0），然后是八进制数字序列（0~7）。如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析。请看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> octalNum1 = <span class="number">070</span>; <span class="comment">//八进制的56</span></div><div class="line"><span class="keyword">var</span> octalNum2 = <span class="number">079</span>; <span class="comment">//无效的八进制数值——解析为79</span></div></pre></td></tr></table></figure>
<p>八进制字面量在严格模式下是无效的，会导致支持的JavaScript引擎抛出错误。</p>
<p>十六进制字面值的前两位必须是0x，后跟任何十六进制数字（0~9及A~F）。其中，字母A~F可以大写，也可以小写。如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> hexNum1 = <span class="number">0xA</span>;  <span class="comment">//十六进制的10</span></div><div class="line"><span class="keyword">var</span> hexNum2 = <span class="number">0x1f</span>; <span class="comment">//十六进制的31</span></div></pre></td></tr></table></figure>
<p>在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。</p>
<h4 id="浮点数值"><a href="#浮点数值" class="headerlink" title="浮点数值"></a>浮点数值</h4><p>所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。虽然小数点前面可以没有整数，但我们不推荐这种写法。</p>
<p>由于保存浮点数值需要的内存空间是保存整数值的两倍，因此ECMAScript会不失时机地将浮点数值转换为整数值。显然，如果小数点后面没有跟任何数字，那么这个数值就可以作为整数值来保存。同样地，如果浮点数值本身表示的就是一个整数（如1.0），那么该值也会被转换为整数，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> floatNum1 = <span class="number">1.</span>;   <span class="comment">//小数点后没有数字——解析为1</span></div><div class="line"><span class="keyword">var</span> floatNum2 = <span class="number">10.0</span>; <span class="comment">//整数——解析为10</span></div></pre></td></tr></table></figure>
<p>对于那些极大或极小的数值，可以用e表示法（即科学计数法）表示的浮点数值表示。</p>
<p>在默认情况下，ECMASctipt会将那些小数点后面带有6个零以上的浮点数值转换为以e表示法表示的数值（例如，0.0000003会被转换成3e-7）。</p>
<p>浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1加0.2的结果不是0.3，而是0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。</p>
<blockquote>
<p>永远不要测试某个特定的浮点数值。</p>
</blockquote>
<h4 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h4><p>由于内存的限制，ECMAScript并不能保存世界上所有的数值。ECMAScript能够表示的最小数值保存在Number.MIN_VALUE中——在大多数浏览器中，这个值是5e-324；能够表示的最大数值保存在Number.MAX_VALUE中——在大多数浏览器中，这个值是1.7976931348623157e+308。如果某次计算的结果得到了一个超出JavaScript数值范围的值，那么这个数值将被自动转换成特殊的Infinity值。具体来说，如果这个数值是负数，则会被转换成-Infinity（负无穷），如果这个数值是正数，则会被转换成Infinity（正无穷）。</p>
<p>如上所述，如果某次计算返回了正或负的Infinity值，那么该值将无法继续参与下一次的计算，因为Infinity不是能够参与计算的数值。要想确定一个数值是不是有穷的（换句话说，是不是位于最小和最大的数值之间），可以使用isFinite()函数。这个函数在参数位于最小与最大数值之间时会返回true。</p>
<p>尽管在计算中很少出现某些值超出表示范围的情况，但在执行极小或极大数值的计算时，检测监控这些值是可能的，也是必需的。<br>访问Number.NEGATIVE_INFINITY和Number.POSITIVE_INFINITY也可以得到负和正Infinity的值。可以想见，这两个属性中分别保存着-Infinity和Infinity。</p>
<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，在其他编程语言中，任何数值除以0都会导致错误，从而停止代码执行。但在ECMAScript中，任何数值除以0会返回NaN，因此不会影响其他代码的执行。</p>
<p>NaN本身有两个非同寻常的特点。首先，任何涉及NaN的操作（例如NaN/10）都会返回NaN，这个特点在多步计算中有可能导致问题。其次，NaN与任何值都不相等，包括NaN本身。</p>
<p>针对NaN的这两个特点，ECMAScript定义了isNaN()函数。这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”。isNaN()在接收到一个值之后，会尝试将这个值转换为数值。某些不是数值的值会直接转换为数值，例如字符串”10”或Boolean值。而任何不能被转换为数值的值都会导致这个函数返回true。</p>
<blockquote>
<p>尽管有点儿不可思议，但isNaN()确实也适用于对象。在基于对象调用isNaN()函数时，会首先调用对象的valueOf()方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个返回值再调用toString()方法，再测试返回值。而这个过程也是ECMAScript中内置函数和操作符的一般执行流程。</p>
</blockquote>
<h4 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h4><p>有3个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat()。第一个函数，即转型函数Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。这3个函数对于同样的输入会有返回不同的结果。</p>
<p>Number()函数转换规则如下:</p>
<ol>
<li>如果是Boolean值，true和false将分别被转换为1和0。</li>
<li>如果是数字值，只是简单的传入和返回。</li>
<li>如果是null值，返回0。</li>
<li>如果是undefined，返回NaN。</li>
<li>如果是字符串，遵循下列规则<ul>
<li>如果字符串中只包含数字（包括前面带加号或头号的情况），则将其转换为十进制数值，即”1”会变成1，”123”会变成123，而”011”会变成11（注意：前导的零被忽略了）</li>
<li>如果字符串中包含有效的浮点格式，如”1.1”，则将其转换为对应的浮点数值（同样，也会忽略前导零）</li>
<li>如果字符串中包含有效的十六进制格式，例如”Oxf”，则将其转换为相同大小的十进制整数值</li>
<li>如果字符串是空的（不包含任何字符），则将其转换为0</li>
<li>如果字符串中包含除上述格式之外的字符，则将其转换为NaN。</li>
</ul>
</li>
<li>如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符串值。</li>
</ol>
<p>由于Number()函数在转换字符串时比较复杂而且不够合理，因此在处理整数的时候更常用的是parseInt()函数。parseInt()函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt()就会返回NaN；也就是说，用parseInt()转换空字符串会返回NaN（Number()对空字符返回0）。如果第一个字符是数字字符，parseInt()会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。例如，”1234blue”会被转换为1234，因为”blue”会被完全忽略。类似地，”22.5”会被转换为22，因为小数点并不是有效的数字字符。<br>如果字符串中的第一个字符是数字字符，parseInt()也能够识别出各种整数格式（即前面讨论的十进制、八进制和十六进制数）。也就是说，如果字符串以”Ox”开头且后跟数字字符，就会将其当作一个十六进制整数；如果字符串以”0”开头且后跟数字字符，则会将其当作一个八进制数来解析。</p>
<p>在ECMAScript 3 JavaScript引擎中，”070”被当成八进制字面量，因此转换后的值是十进制的56。而在ECMAScript 5 JavaScript引擎中，parseInt()已经不具有解析八进制值的能力，因此前导的零会被认为无效，从而将这个值当成”0”，结果就得到十进制的0。在ECMAScript5中，即使是在严格模式下也会如此。</p>
<p>为了消除在使用parseInt()函数时可能导致的上述困惑，可以为这个函数提供第二个参数：转换时使用的基数（即多少进制）。如果知道要解析的值是十六进制格式的字符串，那么指定基数16作为第二个参数，可以保证得到正确的结果，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="built_in">parseInt</span>（<span class="string">"OxAF"</span>, <span class="number">16</span>）； <span class="comment">//175</span></div></pre></td></tr></table></figure>
<p>实际上，如果指定了16作为第二个参数，字符串可以不带前面的”Ox”，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">"AF"</span>, <span class="number">16</span>); <span class="comment">//175</span></div><div class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">"AF"</span>);     <span class="comment">//NaN</span></div></pre></td></tr></table></figure>
<p>这个例子中的第一个转换成功了，而第二个则失败了。差别在于第一个转换传入了基数，明确告诉parseInt()要解析一个十六进制格式的字符串；而第二个转换发现第一个字符不是数字字符，因此就自动终止了。</p>
<p>不指定基数意味着让parseInt()决定如何解析输入的字符串，因此为了避免错误的解析，我们建议无论在什么情况下都明确指定基数。</p>
<p>与parseInt()函数类似，parseFloat()也是从第一个字符（位置0）开始解析每个字符。而且也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的第一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。举例来说，”22.34.5”将会被转换为22.34。</p>
<p>除了第一个小数点有效之外，parseFloat()与parseInt()的第二个区别在于它始终都会忽略前导的零。parseFloat()可以识别前面讨论过的所有浮点数值格式，也包括十进制整数格式。但十六进制格式的字符串则始终会被转换成0。由于parseFloat()只解析十进制值，因此它没有用第二个参数指定基数的用法。最后还要注意一点：如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后都是零），parseFloat()会返回整数。以下是使用parseFloat()转换数值的几个典型示例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseFloat</span>(<span class="string">"1234blue"</span>);  <span class="comment">//1234(整数)</span></div><div class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseFloat</span>(<span class="string">"0xA"</span>);       <span class="comment">//0</span></div><div class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseFloat</span>(<span class="string">"22.5"</span>);      <span class="comment">//22.5</span></div><div class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseFloat</span>(<span class="string">"22.34.5"</span>);   <span class="comment">//22.34</span></div><div class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseFloat</span>(<span class="string">"0908.5"</span>);    <span class="comment">//908.5</span></div><div class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseFloat</span>(<span class="string">"3.125e7"</span>);   <span class="comment">//31250000</span></div></pre></td></tr></table></figure>
<h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由双引号（”）或单引号（’）表示。用双引号表示的字符串和用单引号表示的字符串完全相同。</p>
<h4 id="字符字面量"><a href="#字符字面量" class="headerlink" title="字符字面量"></a>字符字面量</h4><p>String数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符，或者具有其他用途的字符。这些字符字面量如下表所示：<br>| 字面量 | 含义                                                 |<br>|——–|——————————————————|<br>| \n     | 换行                                                 |<br>| \t     | 制表                                                 |<br>| \b     | 空格                                                 |<br>| \r     | 回车                                                 |<br>| \f     | 进纸                                                 |<br>| \     | 斜杠                                                 |<br>| \’     | 单引号（’），在用单引号表示的字符串中使用            |<br>| \”     | 双引号（”），在用双引号表示的字符串中使用            |<br>| \xnn   | 以十六进制代码nn表示的一个字符（其中n为0~F）         |<br>| \unnnn | 以十六进制代码nnnn表示的一个Unicode字符（其中n为0~F）|<br>任何字符串的长度都可以通过访问其length属性取得。</p>
<h4 id="字符串的特点"><a href="#字符串的特点" class="headerlink" title="字符串的特点"></a>字符串的特点</h4><p>ECMAScript中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。</p>
<p>要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的toString()方法。<br>数值、布尔值、对象和字符串值（没错，每个字符串也都有一个toString()方法，该方法返回字符串的一个副本）都有toString()方法。但null和undefined值没有这个方法。</p>
<p>数情况下，调用toString()方法不必传递参数。但是，在调用数值的toString()方法时，可以传递一个参数：输出数值的基数。默认情况下，toString()方法以十进制格式返回数值的字符串表示。而通过传递基数，toString()可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格式表示的字符串值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</div><div class="line">alert(num.toString());   <span class="comment">//"10"</span></div><div class="line">alert(num.toString(<span class="number">2</span>));  <span class="comment">//"1010"</span></div><div class="line">alert(num.toString(<span class="number">8</span>));  <span class="comment">//"12"</span></div><div class="line">alert(num.toString(<span class="number">9</span>));  <span class="comment">//"10"</span></div><div class="line">alert(num.toString(<span class="number">16</span>)); <span class="comment">//"a"</span></div></pre></td></tr></table></figure></p>
<p>在不知道要转换的值是不是null或undefined的情况下，还可以使用转型函数String()，这个函数能够将任何类型的值转换为字符串。String()函数遵循下列转换规则：</p>
<ol>
<li>如果值有toString()方法，则调用该方法（没有参数）并返回相应的结果；</li>
<li>如果值是null，则返回”null”；</li>
<li>如果值是undefined，则返回”undefined”。</li>
</ol>
<blockquote>
<p>要把某个值转换为字符串，可以使用加号操作符（3.5节讨论）把它与一个字符串（””）加在一起。</p>
</blockquote>
<h3 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h3><p>CMAScript中的对象其实就是一组数据和功能的集合。对象可以通过执行new操作符后跟要创建的对象类型的名称来创建。而创建Object类型的实例并为其添加属性和（或）方法，就可以创建自定义对象，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()；</div></pre></td></tr></table></figure>
<p>这个语法与Java中创建对象的语法相似；但在ECMAScript中，如果不给构造函数传递参数，则可以省略后面的那一对圆括号。也就是说，在像前面这个示例一样不传递参数的情况下，完全可以省略那对圆括号（但这不是推荐的做法）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>； <span class="comment">//有效，但不推荐省略圆括号</span></div></pre></td></tr></table></figure>
<p>仅仅创建Object的实例并没有什么用处，但关键是要理解一个重要的思想：即在ECMAScript中，（就像Java中的java.lang.Object对象一样）Object类型是所有它的实例的基础。换句话说，Object类型所具有的任何属性和方法也同样存在于更具体的对象中。</p>
<p>Object的每个实例都具有下列属性和方法:</p>
<ul>
<li>constructor：保存着用于创建当前对象的函数。</li>
<li>hasOwnProperty（propertyName）：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。</li>
<li>isPrototypeOf（object）：用于检查传入的对象是否是另一个对象的原型。</li>
<li>propertyIsEnumerable（propertyName）：用于检查给定的属性是否能够使用for-in语句（本章后面将会讨论）来枚举。</li>
<li>toLocaleString():返回对象的字符串表示，该字符串与执行环境的地区对应。</li>
<li>toString()：返回对象的字符串表示。</li>
<li>valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。</li>
</ul>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><ul>
<li>操作符包括算数操作符，位操作符，关系操作符和相等操作符。</li>
<li>他们可以适用于很多值，包括字符串，数字值，布尔值，甚至对象。</li>
<li>在应用于对象时，通常会调用对象的valueOf()和(或)toString()方法。</li>
</ul>
<h3 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h3><p>只能操作一个值的操作符叫做一元操作符。一元操作符是ECMAScript中最简单的操作符。</p>
<h4 id="递增和递减操作符"><a href="#递增和递减操作符" class="headerlink" title="递增和递减操作符"></a>递增和递减操作符</h4><ul>
<li>前置++ =&gt; ++a</li>
<li>后置++ =&gt; a++</li>
<li>前置– =&gt; –a</li>
<li>后置– =&gt; a–<blockquote>
<p>效果同Ｃ语言<br>不同的是，这四个操作符对任何值都适用。</p>
</blockquote>
</li>
</ul>
<ul>
<li>在应用于一个<strong>包含有效数字字符的字符串</strong>时，先将其转换为数字值，再执行加减1的操作。字符串变量变成数值变量。</li>
<li>在应用于一个<strong>不包含有效数字字符的字符串</strong>时，将变量的值设置为NaN。字符串变量变成数值变量。</li>
<li>在应用于布尔值<strong>false</strong>时，先将其转换为0再执行加减1的操作。布尔值变量变成数值变量。</li>
<li>在应用于布尔值<strong>true</strong>时，先将其转换为1再执行加减1的操作。布尔值变量变成数值变量。</li>
<li>在应用于<strong>浮点数值</strong>时，执行加减1的操作。</li>
<li>在应用于<strong>对象</strong>时，先调用对象的valueOf()方法以取得一个可供操作的值。然后对该值应用前述规则。如果结果是NaN，则在调用toString()方法后再应用前述规则。对象变量变成数值变量。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="string">'2'</span>;</div><div class="line"><span class="keyword">var</span> s2 = <span class="string">'z'</span>;</div><div class="line"><span class="keyword">var</span> s3 = <span class="string">'123z'</span>;</div><div class="line"><span class="keyword">var</span> b1 = <span class="literal">false</span>;</div><div class="line"><span class="keyword">var</span> b2 = <span class="literal">true</span>;</div><div class="line"><span class="keyword">var</span> f = <span class="number">1.1</span>;</div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  <span class="attr">valueOf</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">s1++;    <span class="comment">// s1 == 3</span></div><div class="line">s2++;    <span class="comment">// s2 == NaN</span></div><div class="line">s3++;    <span class="comment">// s3 == NaN</span></div><div class="line">b1--;    <span class="comment">// b1 == -1</span></div><div class="line">b2--;    <span class="comment">// b2 == 0</span></div><div class="line">f--;     <span class="comment">// f  == 0.100000000000009</span></div><div class="line">o--;     <span class="comment">// o == -2</span></div></pre></td></tr></table></figure>
<h4 id="一元加和减操作符"><a href="#一元加和减操作符" class="headerlink" title="一元加和减操作符"></a>一元加和减操作符</h4><ul>
<li>一元加减操作符作用于数值，同Ｃ语言。</li>
<li>一元加操作符作用于数值非数值，等同于Number()转型函数。</li>
<li>一元减操作符作用于数值非数值，等同于一元加操作符最后将其转换成负数。</li>
</ul>
<h3 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h3><ul>
<li>按位非（NOT）<br>按位非操作符由一个波浪线（~）表示，执行按位非的结果就是返回数值的反码。</li>
<li>按位与（AND）<br>按位与操作符由一个和号字符（&amp;）表示，它有两个操作符数。</li>
<li>按位或（OR）<br>按位或操作符由一个竖线符号（|）表示，同样也有两个操作数。</li>
<li>按位异或（XOR）<br>按位异或操作符由一个插入符号（^）表示，也有两个操作数。</li>
<li>左移<br>左移操作符由两个小于号（&lt;&lt;）表示，这个操作符会将数值的所有位向左移动指定的位数。右侧空出用0补充。（左移不影响符号位）</li>
<li>有符号的右移<br>有符号的右移操作符由两个大于号（&gt;&gt;）表示，这个操作符会将数值向右移动，但保留符号位（即正负号标记）。</li>
<li>无符号右移<br>无符号右移操作符由3个大于号（&gt;&gt;&gt;）表示，这个操作符会将数值的所有32位都向右移动。对正数来说，无符号右移的结果与有符号右移相同。对于负数来说则不同。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">-64</span>;     <span class="comment">// 二进制11111111111111111111111111000000</span></div><div class="line"><span class="keyword">var</span> b = a &gt;&gt;&gt; <span class="number">5</span>; <span class="comment">// 二进制00000111111111111111111111111111</span></div></pre></td></tr></table></figure>
<h3 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h3><ul>
<li><p>!</p>
<ul>
<li>如果操作数是一个对象，返回false；</li>
<li>如果操作数是一个空字符串，返回true；</li>
<li>如果操作数是一个非空字符串，返回false；</li>
<li>如果操作数是数值0，返回true； 如果操作数是任意非0数值（包括Infinity），返回false;</li>
<li>如果操作数是null，返回true；</li>
<li>如果操作数是NaN，返回true； 如果操作数是undefined，返回true。<blockquote>
<p><code>!!</code> 等同于 <code>Boolean()</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p>&amp;&amp;    </p>
<ul>
<li>如果第一个操作数是对象，则返回第二个操作数；</li>
<li>如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才会返回该对象；</li>
<li>如果两个操作数都是对象，则返回第二个操作数；</li>
<li>如果有一个操作数是null，则返回null；</li>
<li>如果有一个操作数是NaN，则返回NaN；</li>
<li>如果有一个操作数是undefined，则返回undefined。<blockquote>
<p>不能在逻辑与操作中使用未定义的值</p>
</blockquote>
</li>
</ul>
</li>
<li><p>||</p>
<ul>
<li>如果第一个操作数是对象，则返回第一个操作数；</li>
<li>如果第一个操作数的求值结果为false，则返回第二个操作数；</li>
<li>如果两个操作数都是对象，则返回第一个操作数；</li>
<li>如果两个操作数都是null，则返回null；</li>
<li>如果两个操作数都是NaN，则返回NaN；</li>
<li>如果两个操作数都是undefined，则返回undefined。<blockquote>
<p>可以利用逻辑或的这一行为来避免为变量赋null或undefined值。<br>var myObject = preferredObject || backupObject;</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h3><ul>
<li>*<ul>
<li>如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity；</li>
<li>如果有一个操作数是NaN，则结果是NaN；</li>
<li>如果是Infinity与0相乘，则结果是NaN;</li>
<li>如果是Infinity与非0数值相乘，则结果是Infinity或-Infinity，取决于有符号操作数的符号；</li>
<li>如果是Infinity与Infinity相乘，则结果是Infinity；</li>
<li>如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。</li>
</ul>
</li>
<li>/<ul>
<li>如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果商超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity；</li>
<li>如果有一个操作数是NaN，则结果是NaN；</li>
<li>如果是Infinity被Infinity除，则结果是NaN;</li>
<li>如果是零被零除，则结果是NaN;</li>
<li>如果是非零的有限数被零除，则结果是Infinity或-Infinity，取决于有符号操作数的符号；</li>
<li>如果是Infinity被任何非零数值除，则结果是Infinity或-Infinity，取决于有符号操作数的符号；</li>
<li>如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。</li>
</ul>
</li>
<li>%<ul>
<li>如果操作数都是数值，执行常规的除法计算，返回除得的余数；</li>
<li>如果被除数是无穷大值而除数是有限大的数值，则结果是NaN；</li>
<li>如果被除数是有限大的数值而除数是零，则结果是NaN；</li>
<li>如果是Infinity被Infinity除，则结果是NaN;</li>
<li>如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；</li>
<li>如果被除数是零，则结果是零；</li>
<li>如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。</li>
</ul>
</li>
</ul>
<h3 id="加减操作符"><a href="#加减操作符" class="headerlink" title="加减操作符"></a>加减操作符</h3><ul>
<li><p>+</p>
<ul>
<li>如果有一个操作数是NaN，则结果是NaN；</li>
<li>如果是Infinity加Infinity，则结果是Infinity；</li>
<li>如果是-Infinity加-Infinity，则结果是-Infinity；</li>
<li>如果是Infinity加-Infinity，则结果是NaN；</li>
<li>如果是+0加+0，则结果是+0；</li>
<li>如果是-0加-0，则结果是-0；</li>
<li>如果是+0加-0，则结果是+0。</li>
<li>如果有一个操作数是字符串：<ul>
<li>如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；</li>
<li>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。<blockquote>
<p>如果有一个操作数是对象、数值或布尔值，则调用它们的toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于undefined和null，则分别调用String()函数并取得字符串”undefined”和”null”。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>-</p>
<ul>
<li>如果两个操作符都是数值，则执行常规的算术减法操作并返回结果；</li>
<li>如果有一个操作数是NaN，则结果是NaN；</li>
<li>如果是Infinity减Infinity，则结果是NaN；</li>
<li>如果是-Infinity减-Infinity，则结果是NaN；</li>
<li>如果是Infinity减-Infinity，则结果是Infinity；</li>
<li>如果是-Infinity减Infinity，则结果是-Infinity；</li>
<li>如果是+0减+0，则结果是+0；</li>
<li>如果是+0减-0，则结果是-0；</li>
<li>如果是-0减-0，则结果是+0；</li>
<li>如果有一个操作数是字符串、布尔值、null或undefined，则先在后台调用Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是NaN，则减法的结果就是NaN;</li>
<li>如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值。如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值。</li>
</ul>
</li>
</ul>
<h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><ul>
<li>如果两个操作数都是数值，则执行数值比较。</li>
<li>如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。</li>
<li>如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。</li>
<li>如果一个操作数是对象，则调用这个对象的valueOf()方法，用得到的结果按照前面的规则执行比较。如果对象没有valueOf()方法，则调用toString()方法，并用得到的结果根据前面的规则执行比较。</li>
<li>如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。</li>
</ul>
<h3 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h3><ul>
<li><p>== / !=</p>
<ul>
<li>如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；</li>
<li>如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；</li>
<li>如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较；</li>
<li>null和undefined是相等的。</li>
<li>要比较相等性之前，不能将null和undefined转换成其他任何值。</li>
<li>如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。</li>
<li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false。</li>
</ul>
</li>
<li><p>=== / !==</p>
<ul>
<li>除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。</li>
</ul>
</li>
</ul>
<h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3><ul>
<li><code>variable = boolean_expression ？ true_value : false_value;</code></li>
</ul>
<h3 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h3><ul>
<li>=</li>
<li>+=</li>
<li>-=</li>
<li>*=</li>
<li>/=</li>
<li>%=</li>
<li>&lt;&lt;=</li>
<li><blockquote>
<blockquote>
<p>=</p>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>=</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
<blockquote>
<p>设计这些操作符的主要目的就是简化赋值操作。使用它们不会带来任何性能的提升。</p>
</blockquote>
<h3 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h3><ul>
<li>使用逗号操作符可以在一条语句中执行多个操作；</li>
<li>逗号操作符还可以用于赋值。在用于赋值时，逗号操作符总会返回表达式中的最后一项。</li>
</ul>
<h2 id="流控制语句"><a href="#流控制语句" class="headerlink" title="流控制语句"></a>流控制语句</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p><code>if（condition）statement1 else statement2</code><br>其中的condition（条件）可以是任意表达式；而且对这个表达式求值的结果不一定是布尔值。ECMAScript会自动调用Boolean()转换函数将这个表达式的结果转换为一个布尔值。如果对condition求值的结果是true，则执行statementl（语句1），如果对condition求值的结果是false，则执行statement2（语句2）。</p>
<h3 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h3><p>do-while语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。</p>
<p>像do-while这种后测试循环语句最常用于循环体中的代码至少要被执行一次的情形。</p>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>while语句属于前测试循环语句，也就是说，在循环体内的代码被执行之前，就会对出口条件求值。</p>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>for语句也是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。</p>
<h3 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h3><p>for-in语句是一种精准的迭代语句，可以用来枚举对象的属性。</p>
<p>ECMAScript对象的属性没有顺序。因此，通过for-in循环输出的属性名的顺序是不可预测的。具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。</p>
<p>但是，如果表示要迭代的对象的变量值为null或undefined，for-in语句会抛出错误。ECMAScript5更正了这一行为；对这种情况不再抛出错误，而只是不执行循环体。为了保证最大限度的兼容性，建议在使用for-in循环之前，先检测确认该对象的值不是null或undefined。</p>
<h3 id="label"><a href="#label" class="headerlink" title="label"></a>label</h3><p>使用label语句可以在代码中添加标签，以便将来使用。</p>
<p>标签可以在将来由break或continue语句引用。</p>
<p>加标签的语句一般都要与for语句等循环语句配合使用。</p>
<h3 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h3><p>break语句会立即退出循环，强制继续执行循环后面的语句。而continue语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。</p>
<h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>with语句的作用是将代码的作用域设置到一个特定的对象中。</p>
<p>定义with语句的目的主要是为了简化多次编写同一个对象的工作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> qs = location.search.substring(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> hostName = location.hostname;</div><div class="line"><span class="keyword">var</span> url = location.href;</div><div class="line"></div><div class="line"><span class="comment">// 等价于</span></div><div class="line"><span class="keyword">with</span>(location) &#123;</div><div class="line">    <span class="keyword">var</span> qs = search.substring(<span class="number">1</span>);</div><div class="line">    <span class="keyword">var</span> hostName = hostname;</div><div class="line">    <span class="keyword">var</span> url = href;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>严格模式下不允许使用with语句，否则将视为语法错误。</p>
<p>由于大量使用with语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用with语句。</p>
</blockquote>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>作用同C语言，不同的是case语句可以是任意类型的常量，变量，表达式。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>ECMAScript中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）。</li>
<li>在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。</li>
<li>命名的参数只提供便利，但不是必需的。</li>
<li>arguments对象可以与命名参数一起使用。</li>
<li>修改arguments中的值会改变命名参数对应的值。</li>
<li>修改命名参数不会改变arguments中对应的值。</li>
<li>没有传递值的命名参数将自动被赋予undefined值。</li>
<li>严格模式对如何使用argumetns对象做出了一些限制。<ul>
<li>修改arguments的值，将不会修改对应命名参数的值。</li>
<li>重写arguments的值会导致语法错误（代码将不会执行）。</li>
</ul>
</li>
<li>ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数。</li>
<li>没有重载，后定义函数会覆盖先定义函数。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="Lisiur Day" />
          <p class="site-author-name" itemprop="name">Lisiur Day</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">21</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lisiur Day</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
